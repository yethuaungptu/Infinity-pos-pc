
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionItem
 * 
 */
export type TransactionItem = $Result.DefaultSelection<Prisma.$TransactionItemPayload>
/**
 * Model EggCollection
 * 
 */
export type EggCollection = $Result.DefaultSelection<Prisma.$EggCollectionPayload>
/**
 * Model CollectionRoute
 * 
 */
export type CollectionRoute = $Result.DefaultSelection<Prisma.$CollectionRoutePayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model PaymentRecord
 * 
 */
export type PaymentRecord = $Result.DefaultSelection<Prisma.$PaymentRecordPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StaffPosition: {
  MANAGER: 'MANAGER',
  CASHIER: 'CASHIER',
  COLLECTOR: 'COLLECTOR',
  ADMIN: 'ADMIN',
  SUPERVISOR: 'SUPERVISOR'
};

export type StaffPosition = (typeof StaffPosition)[keyof typeof StaffPosition]


export const StaffDepartment: {
  SALES: 'SALES',
  COLLECTION: 'COLLECTION',
  INVENTORY: 'INVENTORY',
  ADMIN: 'ADMIN',
  MANAGEMENT: 'MANAGEMENT'
};

export type StaffDepartment = (typeof StaffDepartment)[keyof typeof StaffDepartment]


export const CustomerType: {
  FARMER: 'FARMER',
  REGULAR: 'REGULAR',
  WHOLESALE: 'WHOLESALE'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const CreditStatus: {
  CURRENT: 'CURRENT',
  OVERDUE_30: 'OVERDUE_30',
  OVERDUE_60: 'OVERDUE_60',
  OVERDUE_90: 'OVERDUE_90',
  BAD_DEBT: 'BAD_DEBT'
};

export type CreditStatus = (typeof CreditStatus)[keyof typeof CreditStatus]


export const CollectionSchedule: {
  DAILY: 'DAILY',
  ALTERNATE: 'ALTERNATE',
  WEEKLY: 'WEEKLY',
  CUSTOM: 'CUSTOM'
};

export type CollectionSchedule = (typeof CollectionSchedule)[keyof typeof CollectionSchedule]


export const ProductType: {
  FEED: 'FEED',
  MEDICINE: 'MEDICINE',
  EQUIPMENT: 'EQUIPMENT',
  EGGS: 'EGGS',
  SUPPLIES: 'SUPPLIES',
  OTHER: 'OTHER'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const TransactionType: {
  SALE: 'SALE',
  PURCHASE: 'PURCHASE',
  EGG_COLLECTION: 'EGG_COLLECTION',
  EGG_SALE: 'EGG_SALE',
  REFUND: 'REFUND',
  ADJUSTMENT: 'ADJUSTMENT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT: 'CREDIT',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHECK: 'CHECK',
  DIGITAL: 'DIGITAL'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  PARTIAL_REFUND: 'PARTIAL_REFUND'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const PurchaseOrderStatus: {
  PENDING: 'PENDING',
  ORDERED: 'ORDERED',
  PARTIAL_RECEIVED: 'PARTIAL_RECEIVED',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseOrderStatus = (typeof PurchaseOrderStatus)[keyof typeof PurchaseOrderStatus]


export const PaymentType: {
  CUSTOMER_PAYMENT: 'CUSTOMER_PAYMENT',
  VENDOR_PAYMENT: 'VENDOR_PAYMENT',
  EGG_PAYMENT: 'EGG_PAYMENT',
  REFUND: 'REFUND',
  ADJUSTMENT: 'ADJUSTMENT',
  DEBIT: 'DEBIT'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const SettingType: {
  STRING: 'STRING',
  NUMBER: 'NUMBER',
  BOOLEAN: 'BOOLEAN',
  JSON: 'JSON'
};

export type SettingType = (typeof SettingType)[keyof typeof SettingType]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  SYNC: 'SYNC'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const SyncOperation: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  BULK_SYNC: 'BULK_SYNC'
};

export type SyncOperation = (typeof SyncOperation)[keyof typeof SyncOperation]


export const NotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  ALERT: 'ALERT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationCategory: {
  INVENTORY: 'INVENTORY',
  SALES: 'SALES',
  CUSTOMER: 'CUSTOMER',
  VENDOR: 'VENDOR',
  SYSTEM: 'SYSTEM',
  QUALITY: 'QUALITY',
  FINANCIAL: 'FINANCIAL'
};

export type NotificationCategory = (typeof NotificationCategory)[keyof typeof NotificationCategory]


export const NotificationPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]

}

export type StaffPosition = $Enums.StaffPosition

export const StaffPosition: typeof $Enums.StaffPosition

export type StaffDepartment = $Enums.StaffDepartment

export const StaffDepartment: typeof $Enums.StaffDepartment

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type CreditStatus = $Enums.CreditStatus

export const CreditStatus: typeof $Enums.CreditStatus

export type CollectionSchedule = $Enums.CollectionSchedule

export const CollectionSchedule: typeof $Enums.CollectionSchedule

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type PurchaseOrderStatus = $Enums.PurchaseOrderStatus

export const PurchaseOrderStatus: typeof $Enums.PurchaseOrderStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type SettingType = $Enums.SettingType

export const SettingType: typeof $Enums.SettingType

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type SyncOperation = $Enums.SyncOperation

export const SyncOperation: typeof $Enums.SyncOperation

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationCategory = $Enums.NotificationCategory

export const NotificationCategory: typeof $Enums.NotificationCategory

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Stores
 * const stores = await prisma.store.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Stores
   * const stores = await prisma.store.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionItem`: Exposes CRUD operations for the **TransactionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionItems
    * const transactionItems = await prisma.transactionItem.findMany()
    * ```
    */
  get transactionItem(): Prisma.TransactionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eggCollection`: Exposes CRUD operations for the **EggCollection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EggCollections
    * const eggCollections = await prisma.eggCollection.findMany()
    * ```
    */
  get eggCollection(): Prisma.EggCollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionRoute`: Exposes CRUD operations for the **CollectionRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionRoutes
    * const collectionRoutes = await prisma.collectionRoute.findMany()
    * ```
    */
  get collectionRoute(): Prisma.CollectionRouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentRecord`: Exposes CRUD operations for the **PaymentRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentRecords
    * const paymentRecords = await prisma.paymentRecord.findMany()
    * ```
    */
  get paymentRecord(): Prisma.PaymentRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Store: 'Store',
    Staff: 'Staff',
    Customer: 'Customer',
    Vendor: 'Vendor',
    Product: 'Product',
    Transaction: 'Transaction',
    TransactionItem: 'TransactionItem',
    EggCollection: 'EggCollection',
    CollectionRoute: 'CollectionRoute',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    PaymentRecord: 'PaymentRecord',
    SystemSetting: 'SystemSetting',
    AuditLog: 'AuditLog',
    SyncLog: 'SyncLog',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    localdb?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "store" | "staff" | "customer" | "vendor" | "product" | "transaction" | "transactionItem" | "eggCollection" | "collectionRoute" | "purchaseOrder" | "purchaseOrderItem" | "paymentRecord" | "systemSetting" | "auditLog" | "syncLog" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionItem: {
        payload: Prisma.$TransactionItemPayload<ExtArgs>
        fields: Prisma.TransactionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          findFirst: {
            args: Prisma.TransactionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          findMany: {
            args: Prisma.TransactionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          create: {
            args: Prisma.TransactionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          createMany: {
            args: Prisma.TransactionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          delete: {
            args: Prisma.TransactionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          update: {
            args: Prisma.TransactionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          deleteMany: {
            args: Prisma.TransactionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          upsert: {
            args: Prisma.TransactionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          aggregate: {
            args: Prisma.TransactionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionItem>
          }
          groupBy: {
            args: Prisma.TransactionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionItemCountAggregateOutputType> | number
          }
        }
      }
      EggCollection: {
        payload: Prisma.$EggCollectionPayload<ExtArgs>
        fields: Prisma.EggCollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EggCollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EggCollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>
          }
          findFirst: {
            args: Prisma.EggCollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EggCollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>
          }
          findMany: {
            args: Prisma.EggCollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>[]
          }
          create: {
            args: Prisma.EggCollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>
          }
          createMany: {
            args: Prisma.EggCollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EggCollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>[]
          }
          delete: {
            args: Prisma.EggCollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>
          }
          update: {
            args: Prisma.EggCollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>
          }
          deleteMany: {
            args: Prisma.EggCollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EggCollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EggCollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>[]
          }
          upsert: {
            args: Prisma.EggCollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggCollectionPayload>
          }
          aggregate: {
            args: Prisma.EggCollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEggCollection>
          }
          groupBy: {
            args: Prisma.EggCollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EggCollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EggCollectionCountArgs<ExtArgs>
            result: $Utils.Optional<EggCollectionCountAggregateOutputType> | number
          }
        }
      }
      CollectionRoute: {
        payload: Prisma.$CollectionRoutePayload<ExtArgs>
        fields: Prisma.CollectionRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>
          }
          findFirst: {
            args: Prisma.CollectionRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>
          }
          findMany: {
            args: Prisma.CollectionRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>[]
          }
          create: {
            args: Prisma.CollectionRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>
          }
          createMany: {
            args: Prisma.CollectionRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>[]
          }
          delete: {
            args: Prisma.CollectionRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>
          }
          update: {
            args: Prisma.CollectionRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>
          }
          deleteMany: {
            args: Prisma.CollectionRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionRouteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>[]
          }
          upsert: {
            args: Prisma.CollectionRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionRoutePayload>
          }
          aggregate: {
            args: Prisma.CollectionRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionRoute>
          }
          groupBy: {
            args: Prisma.CollectionRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionRouteCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionRouteCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      PaymentRecord: {
        payload: Prisma.$PaymentRecordPayload<ExtArgs>
        fields: Prisma.PaymentRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
          }
          findFirst: {
            args: Prisma.PaymentRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
          }
          findMany: {
            args: Prisma.PaymentRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>[]
          }
          create: {
            args: Prisma.PaymentRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
          }
          createMany: {
            args: Prisma.PaymentRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>[]
          }
          delete: {
            args: Prisma.PaymentRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
          }
          update: {
            args: Prisma.PaymentRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
          }
          deleteMany: {
            args: Prisma.PaymentRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>[]
          }
          upsert: {
            args: Prisma.PaymentRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRecordPayload>
          }
          aggregate: {
            args: Prisma.PaymentRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentRecord>
          }
          groupBy: {
            args: Prisma.PaymentRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentRecordCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    store?: StoreOmit
    staff?: StaffOmit
    customer?: CustomerOmit
    vendor?: VendorOmit
    product?: ProductOmit
    transaction?: TransactionOmit
    transactionItem?: TransactionItemOmit
    eggCollection?: EggCollectionOmit
    collectionRoute?: CollectionRouteOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderItem?: PurchaseOrderItemOmit
    paymentRecord?: PaymentRecordOmit
    systemSetting?: SystemSettingOmit
    auditLog?: AuditLogOmit
    syncLog?: SyncLogOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    transactions: number
    eggCollections: number
    paymentRecords: number
    collectionRoutes: number
    PurchaseOrder: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | StaffCountOutputTypeCountTransactionsArgs
    eggCollections?: boolean | StaffCountOutputTypeCountEggCollectionsArgs
    paymentRecords?: boolean | StaffCountOutputTypeCountPaymentRecordsArgs
    collectionRoutes?: boolean | StaffCountOutputTypeCountCollectionRoutesArgs
    PurchaseOrder?: boolean | StaffCountOutputTypeCountPurchaseOrderArgs
  }

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountEggCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggCollectionWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountPaymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRecordWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountCollectionRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionRouteWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountPurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    transactions: number
    eggCollections: number
    paymentRecords: number
    routes: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
    eggCollections?: boolean | CustomerCountOutputTypeCountEggCollectionsArgs
    paymentRecords?: boolean | CustomerCountOutputTypeCountPaymentRecordsArgs
    routes?: boolean | CustomerCountOutputTypeCountRoutesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountEggCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggCollectionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRecordWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionRouteWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    products: number
    purchaseOrders: number
    paymentRecords: number
    Transaction: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | VendorCountOutputTypeCountProductsArgs
    purchaseOrders?: boolean | VendorCountOutputTypeCountPurchaseOrdersArgs
    paymentRecords?: boolean | VendorCountOutputTypeCountPaymentRecordsArgs
    Transaction?: boolean | VendorCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPaymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRecordWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    transactionItems: number
    purchaseOrderItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionItems?: boolean | ProductCountOutputTypeCountTransactionItemsArgs
    purchaseOrderItems?: boolean | ProductCountOutputTypeCountPurchaseOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransactionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    items: number
    paymentRecords: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransactionCountOutputTypeCountItemsArgs
    paymentRecords?: boolean | TransactionCountOutputTypeCountPaymentRecordsArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountPaymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRecordWhereInput
  }


  /**
   * Count Type CollectionRouteCountOutputType
   */

  export type CollectionRouteCountOutputType = {
    customers: number
    eggCollections: number
  }

  export type CollectionRouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CollectionRouteCountOutputTypeCountCustomersArgs
    eggCollections?: boolean | CollectionRouteCountOutputTypeCountEggCollectionsArgs
  }

  // Custom InputTypes
  /**
   * CollectionRouteCountOutputType without action
   */
  export type CollectionRouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRouteCountOutputType
     */
    select?: CollectionRouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionRouteCountOutputType without action
   */
  export type CollectionRouteCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * CollectionRouteCountOutputType without action
   */
  export type CollectionRouteCountOutputTypeCountEggCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggCollectionWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    taxRate: number | null
    creditTermsDefault: number | null
    maxCreditLimit: number | null
    interestRate: number | null
  }

  export type StoreSumAggregateOutputType = {
    taxRate: number | null
    creditTermsDefault: number | null
    maxCreditLimit: number | null
    interestRate: number | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    taxRate: number | null
    currency: string | null
    timezone: string | null
    receiptHeader: string | null
    receiptFooter: string | null
    printLogo: boolean | null
    logoData: string | null
    creditTermsDefault: number | null
    maxCreditLimit: number | null
    interestRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    taxRate: number | null
    currency: string | null
    timezone: string | null
    receiptHeader: string | null
    receiptFooter: string | null
    printLogo: boolean | null
    logoData: string | null
    creditTermsDefault: number | null
    maxCreditLimit: number | null
    interestRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    website: number
    taxRate: number
    currency: number
    timezone: number
    receiptHeader: number
    receiptFooter: number
    printLogo: number
    logoData: number
    creditTermsDefault: number
    maxCreditLimit: number
    interestRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    taxRate?: true
    creditTermsDefault?: true
    maxCreditLimit?: true
    interestRate?: true
  }

  export type StoreSumAggregateInputType = {
    taxRate?: true
    creditTermsDefault?: true
    maxCreditLimit?: true
    interestRate?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    taxRate?: true
    currency?: true
    timezone?: true
    receiptHeader?: true
    receiptFooter?: true
    printLogo?: true
    logoData?: true
    creditTermsDefault?: true
    maxCreditLimit?: true
    interestRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    taxRate?: true
    currency?: true
    timezone?: true
    receiptHeader?: true
    receiptFooter?: true
    printLogo?: true
    logoData?: true
    creditTermsDefault?: true
    maxCreditLimit?: true
    interestRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    taxRate?: true
    currency?: true
    timezone?: true
    receiptHeader?: true
    receiptFooter?: true
    printLogo?: true
    logoData?: true
    creditTermsDefault?: true
    maxCreditLimit?: true
    interestRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string
    email: string | null
    website: string | null
    taxRate: number
    currency: string
    timezone: string
    receiptHeader: string | null
    receiptFooter: string | null
    printLogo: boolean
    logoData: string | null
    creditTermsDefault: number
    maxCreditLimit: number
    interestRate: number
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    taxRate?: boolean
    currency?: boolean
    timezone?: boolean
    receiptHeader?: boolean
    receiptFooter?: boolean
    printLogo?: boolean
    logoData?: boolean
    creditTermsDefault?: boolean
    maxCreditLimit?: boolean
    interestRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    taxRate?: boolean
    currency?: boolean
    timezone?: boolean
    receiptHeader?: boolean
    receiptFooter?: boolean
    printLogo?: boolean
    logoData?: boolean
    creditTermsDefault?: boolean
    maxCreditLimit?: boolean
    interestRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    taxRate?: boolean
    currency?: boolean
    timezone?: boolean
    receiptHeader?: boolean
    receiptFooter?: boolean
    printLogo?: boolean
    logoData?: boolean
    creditTermsDefault?: boolean
    maxCreditLimit?: boolean
    interestRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    taxRate?: boolean
    currency?: boolean
    timezone?: boolean
    receiptHeader?: boolean
    receiptFooter?: boolean
    printLogo?: boolean
    logoData?: boolean
    creditTermsDefault?: boolean
    maxCreditLimit?: boolean
    interestRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "email" | "website" | "taxRate" | "currency" | "timezone" | "receiptHeader" | "receiptFooter" | "printLogo" | "logoData" | "creditTermsDefault" | "maxCreditLimit" | "interestRate" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string
      email: string | null
      website: string | null
      taxRate: number
      currency: string
      timezone: string
      receiptHeader: string | null
      receiptFooter: string | null
      printLogo: boolean
      logoData: string | null
      creditTermsDefault: number
      maxCreditLimit: number
      interestRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly address: FieldRef<"Store", 'String'>
    readonly phone: FieldRef<"Store", 'String'>
    readonly email: FieldRef<"Store", 'String'>
    readonly website: FieldRef<"Store", 'String'>
    readonly taxRate: FieldRef<"Store", 'Float'>
    readonly currency: FieldRef<"Store", 'String'>
    readonly timezone: FieldRef<"Store", 'String'>
    readonly receiptHeader: FieldRef<"Store", 'String'>
    readonly receiptFooter: FieldRef<"Store", 'String'>
    readonly printLogo: FieldRef<"Store", 'Boolean'>
    readonly logoData: FieldRef<"Store", 'String'>
    readonly creditTermsDefault: FieldRef<"Store", 'Int'>
    readonly maxCreditLimit: FieldRef<"Store", 'Float'>
    readonly interestRate: FieldRef<"Store", 'Float'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffAvgAggregateOutputType = {
    salary: number | null
    totalCollections: number | null
    averageQuality: number | null
    onTimeRate: number | null
  }

  export type StaffSumAggregateOutputType = {
    salary: number | null
    totalCollections: number | null
    averageQuality: number | null
    onTimeRate: number | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    position: $Enums.StaffPosition | null
    department: $Enums.StaffDepartment | null
    hireDate: Date | null
    salary: number | null
    active: boolean | null
    username: string | null
    password: string | null
    lastLogin: Date | null
    totalCollections: number | null
    averageQuality: number | null
    onTimeRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    position: $Enums.StaffPosition | null
    department: $Enums.StaffDepartment | null
    hireDate: Date | null
    salary: number | null
    active: boolean | null
    username: string | null
    password: string | null
    lastLogin: Date | null
    totalCollections: number | null
    averageQuality: number | null
    onTimeRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    employeeId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    position: number
    department: number
    hireDate: number
    salary: number
    active: number
    username: number
    password: number
    lastLogin: number
    permissions: number
    totalCollections: number
    averageQuality: number
    onTimeRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffAvgAggregateInputType = {
    salary?: true
    totalCollections?: true
    averageQuality?: true
    onTimeRate?: true
  }

  export type StaffSumAggregateInputType = {
    salary?: true
    totalCollections?: true
    averageQuality?: true
    onTimeRate?: true
  }

  export type StaffMinAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    department?: true
    hireDate?: true
    salary?: true
    active?: true
    username?: true
    password?: true
    lastLogin?: true
    totalCollections?: true
    averageQuality?: true
    onTimeRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    department?: true
    hireDate?: true
    salary?: true
    active?: true
    username?: true
    password?: true
    lastLogin?: true
    totalCollections?: true
    averageQuality?: true
    onTimeRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    department?: true
    hireDate?: true
    salary?: true
    active?: true
    username?: true
    password?: true
    lastLogin?: true
    permissions?: true
    totalCollections?: true
    averageQuality?: true
    onTimeRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _avg?: StaffAvgAggregateInputType
    _sum?: StaffSumAggregateInputType
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    employeeId: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date
    salary: number
    active: boolean
    username: string
    password: string | null
    lastLogin: Date | null
    permissions: JsonValue
    totalCollections: number | null
    averageQuality: number | null
    onTimeRate: number | null
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    department?: boolean
    hireDate?: boolean
    salary?: boolean
    active?: boolean
    username?: boolean
    password?: boolean
    lastLogin?: boolean
    permissions?: boolean
    totalCollections?: boolean
    averageQuality?: boolean
    onTimeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Staff$transactionsArgs<ExtArgs>
    eggCollections?: boolean | Staff$eggCollectionsArgs<ExtArgs>
    paymentRecords?: boolean | Staff$paymentRecordsArgs<ExtArgs>
    collectionRoutes?: boolean | Staff$collectionRoutesArgs<ExtArgs>
    PurchaseOrder?: boolean | Staff$PurchaseOrderArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    department?: boolean
    hireDate?: boolean
    salary?: boolean
    active?: boolean
    username?: boolean
    password?: boolean
    lastLogin?: boolean
    permissions?: boolean
    totalCollections?: boolean
    averageQuality?: boolean
    onTimeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    department?: boolean
    hireDate?: boolean
    salary?: boolean
    active?: boolean
    username?: boolean
    password?: boolean
    lastLogin?: boolean
    permissions?: boolean
    totalCollections?: boolean
    averageQuality?: boolean
    onTimeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    department?: boolean
    hireDate?: boolean
    salary?: boolean
    active?: boolean
    username?: boolean
    password?: boolean
    lastLogin?: boolean
    permissions?: boolean
    totalCollections?: boolean
    averageQuality?: boolean
    onTimeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "firstName" | "lastName" | "email" | "phone" | "position" | "department" | "hireDate" | "salary" | "active" | "username" | "password" | "lastLogin" | "permissions" | "totalCollections" | "averageQuality" | "onTimeRate" | "createdAt" | "updatedAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Staff$transactionsArgs<ExtArgs>
    eggCollections?: boolean | Staff$eggCollectionsArgs<ExtArgs>
    paymentRecords?: boolean | Staff$paymentRecordsArgs<ExtArgs>
    collectionRoutes?: boolean | Staff$collectionRoutesArgs<ExtArgs>
    PurchaseOrder?: boolean | Staff$PurchaseOrderArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      eggCollections: Prisma.$EggCollectionPayload<ExtArgs>[]
      paymentRecords: Prisma.$PaymentRecordPayload<ExtArgs>[]
      collectionRoutes: Prisma.$CollectionRoutePayload<ExtArgs>[]
      PurchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      position: $Enums.StaffPosition
      department: $Enums.StaffDepartment
      hireDate: Date
      salary: number
      active: boolean
      username: string
      password: string | null
      lastLogin: Date | null
      permissions: Prisma.JsonValue
      totalCollections: number | null
      averageQuality: number | null
      onTimeRate: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Staff$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eggCollections<T extends Staff$eggCollectionsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$eggCollectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentRecords<T extends Staff$paymentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$paymentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collectionRoutes<T extends Staff$collectionRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Staff$collectionRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseOrder<T extends Staff$PurchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Staff$PurchaseOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly employeeId: FieldRef<"Staff", 'String'>
    readonly firstName: FieldRef<"Staff", 'String'>
    readonly lastName: FieldRef<"Staff", 'String'>
    readonly email: FieldRef<"Staff", 'String'>
    readonly phone: FieldRef<"Staff", 'String'>
    readonly position: FieldRef<"Staff", 'StaffPosition'>
    readonly department: FieldRef<"Staff", 'StaffDepartment'>
    readonly hireDate: FieldRef<"Staff", 'DateTime'>
    readonly salary: FieldRef<"Staff", 'Int'>
    readonly active: FieldRef<"Staff", 'Boolean'>
    readonly username: FieldRef<"Staff", 'String'>
    readonly password: FieldRef<"Staff", 'String'>
    readonly lastLogin: FieldRef<"Staff", 'DateTime'>
    readonly permissions: FieldRef<"Staff", 'Json'>
    readonly totalCollections: FieldRef<"Staff", 'Int'>
    readonly averageQuality: FieldRef<"Staff", 'Float'>
    readonly onTimeRate: FieldRef<"Staff", 'Float'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.transactions
   */
  export type Staff$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Staff.eggCollections
   */
  export type Staff$eggCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    where?: EggCollectionWhereInput
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    cursor?: EggCollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EggCollectionScalarFieldEnum | EggCollectionScalarFieldEnum[]
  }

  /**
   * Staff.paymentRecords
   */
  export type Staff$paymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    where?: PaymentRecordWhereInput
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    cursor?: PaymentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * Staff.collectionRoutes
   */
  export type Staff$collectionRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    where?: CollectionRouteWhereInput
    orderBy?: CollectionRouteOrderByWithRelationInput | CollectionRouteOrderByWithRelationInput[]
    cursor?: CollectionRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionRouteScalarFieldEnum | CollectionRouteScalarFieldEnum[]
  }

  /**
   * Staff.PurchaseOrder
   */
  export type Staff$PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    farmSize: number | null
    henEggsDailyProduction: number | null
    duckEggsDailyProduction: number | null
    loyaltyPoints: number | null
    totalPurchases: number | null
    totalEggSales: number | null
  }

  export type CustomerSumAggregateOutputType = {
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    farmSize: number | null
    henEggsDailyProduction: number | null
    duckEggsDailyProduction: number | null
    loyaltyPoints: number | null
    totalPurchases: number | null
    totalEggSales: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    type: $Enums.CustomerType | null
    businessName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    creditStatus: $Enums.CreditStatus | null
    farmSize: number | null
    henEggsDailyProduction: number | null
    duckEggsDailyProduction: number | null
    collectionSchedule: $Enums.CollectionSchedule | null
    isRetail: boolean | null
    loyaltyPoints: number | null
    totalPurchases: number | null
    totalEggSales: number | null
    lastPurchase: Date | null
    lastEggCollection: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    type: $Enums.CustomerType | null
    businessName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    creditStatus: $Enums.CreditStatus | null
    farmSize: number | null
    henEggsDailyProduction: number | null
    duckEggsDailyProduction: number | null
    collectionSchedule: $Enums.CollectionSchedule | null
    isRetail: boolean | null
    loyaltyPoints: number | null
    totalPurchases: number | null
    totalEggSales: number | null
    lastPurchase: Date | null
    lastEggCollection: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    type: number
    businessName: number
    contactPerson: number
    email: number
    phone: number
    address: number
    creditLimit: number
    creditBalance: number
    paymentTerms: number
    creditStatus: number
    farmSize: number
    animalTypes: number
    henEggsDailyProduction: number
    duckEggsDailyProduction: number
    collectionSchedule: number
    isRetail: number
    loyaltyPoints: number
    totalPurchases: number
    totalEggSales: number
    lastPurchase: number
    lastEggCollection: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    farmSize?: true
    henEggsDailyProduction?: true
    duckEggsDailyProduction?: true
    loyaltyPoints?: true
    totalPurchases?: true
    totalEggSales?: true
  }

  export type CustomerSumAggregateInputType = {
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    farmSize?: true
    henEggsDailyProduction?: true
    duckEggsDailyProduction?: true
    loyaltyPoints?: true
    totalPurchases?: true
    totalEggSales?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    type?: true
    businessName?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    creditStatus?: true
    farmSize?: true
    henEggsDailyProduction?: true
    duckEggsDailyProduction?: true
    collectionSchedule?: true
    isRetail?: true
    loyaltyPoints?: true
    totalPurchases?: true
    totalEggSales?: true
    lastPurchase?: true
    lastEggCollection?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    type?: true
    businessName?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    creditStatus?: true
    farmSize?: true
    henEggsDailyProduction?: true
    duckEggsDailyProduction?: true
    collectionSchedule?: true
    isRetail?: true
    loyaltyPoints?: true
    totalPurchases?: true
    totalEggSales?: true
    lastPurchase?: true
    lastEggCollection?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    type?: true
    businessName?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    creditStatus?: true
    farmSize?: true
    animalTypes?: true
    henEggsDailyProduction?: true
    duckEggsDailyProduction?: true
    collectionSchedule?: true
    isRetail?: true
    loyaltyPoints?: true
    totalPurchases?: true
    totalEggSales?: true
    lastPurchase?: true
    lastEggCollection?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    type: $Enums.CustomerType
    businessName: string | null
    contactPerson: string
    email: string | null
    phone: string | null
    address: string | null
    creditLimit: number
    creditBalance: number
    paymentTerms: number
    creditStatus: $Enums.CreditStatus
    farmSize: number | null
    animalTypes: JsonValue | null
    henEggsDailyProduction: number
    duckEggsDailyProduction: number
    collectionSchedule: $Enums.CollectionSchedule
    isRetail: boolean
    loyaltyPoints: number
    totalPurchases: number
    totalEggSales: number
    lastPurchase: Date | null
    lastEggCollection: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    businessName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    creditStatus?: boolean
    farmSize?: boolean
    animalTypes?: boolean
    henEggsDailyProduction?: boolean
    duckEggsDailyProduction?: boolean
    collectionSchedule?: boolean
    isRetail?: boolean
    loyaltyPoints?: boolean
    totalPurchases?: boolean
    totalEggSales?: boolean
    lastPurchase?: boolean
    lastEggCollection?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    eggCollections?: boolean | Customer$eggCollectionsArgs<ExtArgs>
    paymentRecords?: boolean | Customer$paymentRecordsArgs<ExtArgs>
    routes?: boolean | Customer$routesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    businessName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    creditStatus?: boolean
    farmSize?: boolean
    animalTypes?: boolean
    henEggsDailyProduction?: boolean
    duckEggsDailyProduction?: boolean
    collectionSchedule?: boolean
    isRetail?: boolean
    loyaltyPoints?: boolean
    totalPurchases?: boolean
    totalEggSales?: boolean
    lastPurchase?: boolean
    lastEggCollection?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    businessName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    creditStatus?: boolean
    farmSize?: boolean
    animalTypes?: boolean
    henEggsDailyProduction?: boolean
    duckEggsDailyProduction?: boolean
    collectionSchedule?: boolean
    isRetail?: boolean
    loyaltyPoints?: boolean
    totalPurchases?: boolean
    totalEggSales?: boolean
    lastPurchase?: boolean
    lastEggCollection?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    type?: boolean
    businessName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    creditStatus?: boolean
    farmSize?: boolean
    animalTypes?: boolean
    henEggsDailyProduction?: boolean
    duckEggsDailyProduction?: boolean
    collectionSchedule?: boolean
    isRetail?: boolean
    loyaltyPoints?: boolean
    totalPurchases?: boolean
    totalEggSales?: boolean
    lastPurchase?: boolean
    lastEggCollection?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "businessName" | "contactPerson" | "email" | "phone" | "address" | "creditLimit" | "creditBalance" | "paymentTerms" | "creditStatus" | "farmSize" | "animalTypes" | "henEggsDailyProduction" | "duckEggsDailyProduction" | "collectionSchedule" | "isRetail" | "loyaltyPoints" | "totalPurchases" | "totalEggSales" | "lastPurchase" | "lastEggCollection" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    eggCollections?: boolean | Customer$eggCollectionsArgs<ExtArgs>
    paymentRecords?: boolean | Customer$paymentRecordsArgs<ExtArgs>
    routes?: boolean | Customer$routesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      eggCollections: Prisma.$EggCollectionPayload<ExtArgs>[]
      paymentRecords: Prisma.$PaymentRecordPayload<ExtArgs>[]
      routes: Prisma.$CollectionRoutePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.CustomerType
      businessName: string | null
      contactPerson: string
      email: string | null
      phone: string | null
      address: string | null
      creditLimit: number
      creditBalance: number
      paymentTerms: number
      creditStatus: $Enums.CreditStatus
      farmSize: number | null
      animalTypes: Prisma.JsonValue | null
      henEggsDailyProduction: number
      duckEggsDailyProduction: number
      collectionSchedule: $Enums.CollectionSchedule
      isRetail: boolean
      loyaltyPoints: number
      totalPurchases: number
      totalEggSales: number
      lastPurchase: Date | null
      lastEggCollection: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eggCollections<T extends Customer$eggCollectionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$eggCollectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentRecords<T extends Customer$paymentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    routes<T extends Customer$routesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$routesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'CustomerType'>
    readonly businessName: FieldRef<"Customer", 'String'>
    readonly contactPerson: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly creditLimit: FieldRef<"Customer", 'Int'>
    readonly creditBalance: FieldRef<"Customer", 'Int'>
    readonly paymentTerms: FieldRef<"Customer", 'Int'>
    readonly creditStatus: FieldRef<"Customer", 'CreditStatus'>
    readonly farmSize: FieldRef<"Customer", 'Float'>
    readonly animalTypes: FieldRef<"Customer", 'Json'>
    readonly henEggsDailyProduction: FieldRef<"Customer", 'Int'>
    readonly duckEggsDailyProduction: FieldRef<"Customer", 'Int'>
    readonly collectionSchedule: FieldRef<"Customer", 'CollectionSchedule'>
    readonly isRetail: FieldRef<"Customer", 'Boolean'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly totalPurchases: FieldRef<"Customer", 'Int'>
    readonly totalEggSales: FieldRef<"Customer", 'Int'>
    readonly lastPurchase: FieldRef<"Customer", 'DateTime'>
    readonly lastEggCollection: FieldRef<"Customer", 'DateTime'>
    readonly active: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer.eggCollections
   */
  export type Customer$eggCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    where?: EggCollectionWhereInput
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    cursor?: EggCollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EggCollectionScalarFieldEnum | EggCollectionScalarFieldEnum[]
  }

  /**
   * Customer.paymentRecords
   */
  export type Customer$paymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    where?: PaymentRecordWhereInput
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    cursor?: PaymentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * Customer.routes
   */
  export type Customer$routesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    where?: CollectionRouteWhereInput
    orderBy?: CollectionRouteOrderByWithRelationInput | CollectionRouteOrderByWithRelationInput[]
    cursor?: CollectionRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionRouteScalarFieldEnum | CollectionRouteScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    earlyPaymentDiscount: number | null
    totalPurchases: number | null
    onTimePaymentRate: number | null
  }

  export type VendorSumAggregateOutputType = {
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    earlyPaymentDiscount: number | null
    totalPurchases: number | null
    onTimePaymentRate: number | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    earlyPaymentDiscount: number | null
    totalPurchases: number | null
    onTimePaymentRate: number | null
    lastOrder: Date | null
    lastPayment: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    creditLimit: number | null
    creditBalance: number | null
    paymentTerms: number | null
    earlyPaymentDiscount: number | null
    totalPurchases: number | null
    onTimePaymentRate: number | null
    lastOrder: Date | null
    lastPayment: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    companyName: number
    contactPerson: number
    email: number
    phone: number
    street: number
    city: number
    state: number
    zipCode: number
    country: number
    creditLimit: number
    creditBalance: number
    paymentTerms: number
    earlyPaymentDiscount: number
    productTypes: number
    totalPurchases: number
    onTimePaymentRate: number
    lastOrder: number
    lastPayment: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    earlyPaymentDiscount?: true
    totalPurchases?: true
    onTimePaymentRate?: true
  }

  export type VendorSumAggregateInputType = {
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    earlyPaymentDiscount?: true
    totalPurchases?: true
    onTimePaymentRate?: true
  }

  export type VendorMinAggregateInputType = {
    id?: true
    companyName?: true
    contactPerson?: true
    email?: true
    phone?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    earlyPaymentDiscount?: true
    totalPurchases?: true
    onTimePaymentRate?: true
    lastOrder?: true
    lastPayment?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactPerson?: true
    email?: true
    phone?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    earlyPaymentDiscount?: true
    totalPurchases?: true
    onTimePaymentRate?: true
    lastOrder?: true
    lastPayment?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    companyName?: true
    contactPerson?: true
    email?: true
    phone?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    creditLimit?: true
    creditBalance?: true
    paymentTerms?: true
    earlyPaymentDiscount?: true
    productTypes?: true
    totalPurchases?: true
    onTimePaymentRate?: true
    lastOrder?: true
    lastPayment?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    companyName: string
    contactPerson: string
    email: string | null
    phone: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string
    creditLimit: number
    creditBalance: number
    paymentTerms: number
    earlyPaymentDiscount: number | null
    productTypes: JsonValue
    totalPurchases: number
    onTimePaymentRate: number
    lastOrder: Date | null
    lastPayment: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    earlyPaymentDiscount?: boolean
    productTypes?: boolean
    totalPurchases?: boolean
    onTimePaymentRate?: boolean
    lastOrder?: boolean
    lastPayment?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Vendor$productsArgs<ExtArgs>
    purchaseOrders?: boolean | Vendor$purchaseOrdersArgs<ExtArgs>
    paymentRecords?: boolean | Vendor$paymentRecordsArgs<ExtArgs>
    Transaction?: boolean | Vendor$TransactionArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    earlyPaymentDiscount?: boolean
    productTypes?: boolean
    totalPurchases?: boolean
    onTimePaymentRate?: boolean
    lastOrder?: boolean
    lastPayment?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    earlyPaymentDiscount?: boolean
    productTypes?: boolean
    totalPurchases?: boolean
    onTimePaymentRate?: boolean
    lastOrder?: boolean
    lastPayment?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    companyName?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    creditLimit?: boolean
    creditBalance?: boolean
    paymentTerms?: boolean
    earlyPaymentDiscount?: boolean
    productTypes?: boolean
    totalPurchases?: boolean
    onTimePaymentRate?: boolean
    lastOrder?: boolean
    lastPayment?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "contactPerson" | "email" | "phone" | "street" | "city" | "state" | "zipCode" | "country" | "creditLimit" | "creditBalance" | "paymentTerms" | "earlyPaymentDiscount" | "productTypes" | "totalPurchases" | "onTimePaymentRate" | "lastOrder" | "lastPayment" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Vendor$productsArgs<ExtArgs>
    purchaseOrders?: boolean | Vendor$purchaseOrdersArgs<ExtArgs>
    paymentRecords?: boolean | Vendor$paymentRecordsArgs<ExtArgs>
    Transaction?: boolean | Vendor$TransactionArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      paymentRecords: Prisma.$PaymentRecordPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      contactPerson: string
      email: string | null
      phone: string | null
      street: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      country: string
      creditLimit: number
      creditBalance: number
      paymentTerms: number
      earlyPaymentDiscount: number | null
      productTypes: Prisma.JsonValue
      totalPurchases: number
      onTimePaymentRate: number
      lastOrder: Date | null
      lastPayment: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Vendor$productsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Vendor$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentRecords<T extends Vendor$paymentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$paymentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Vendor$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly companyName: FieldRef<"Vendor", 'String'>
    readonly contactPerson: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly street: FieldRef<"Vendor", 'String'>
    readonly city: FieldRef<"Vendor", 'String'>
    readonly state: FieldRef<"Vendor", 'String'>
    readonly zipCode: FieldRef<"Vendor", 'String'>
    readonly country: FieldRef<"Vendor", 'String'>
    readonly creditLimit: FieldRef<"Vendor", 'Float'>
    readonly creditBalance: FieldRef<"Vendor", 'Float'>
    readonly paymentTerms: FieldRef<"Vendor", 'Int'>
    readonly earlyPaymentDiscount: FieldRef<"Vendor", 'Float'>
    readonly productTypes: FieldRef<"Vendor", 'Json'>
    readonly totalPurchases: FieldRef<"Vendor", 'Float'>
    readonly onTimePaymentRate: FieldRef<"Vendor", 'Float'>
    readonly lastOrder: FieldRef<"Vendor", 'DateTime'>
    readonly lastPayment: FieldRef<"Vendor", 'DateTime'>
    readonly active: FieldRef<"Vendor", 'Boolean'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.products
   */
  export type Vendor$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Vendor.purchaseOrders
   */
  export type Vendor$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Vendor.paymentRecords
   */
  export type Vendor$paymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    where?: PaymentRecordWhereInput
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    cursor?: PaymentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * Vendor.Transaction
   */
  export type Vendor$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    costPrice: number | null
    sellingPrice: number | null
    wholesalePrice: number | null
    stock: number | null
    minimumStock: number | null
  }

  export type ProductSumAggregateOutputType = {
    costPrice: number | null
    sellingPrice: number | null
    wholesalePrice: number | null
    stock: number | null
    minimumStock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    type: $Enums.ProductType | null
    category: string | null
    costPrice: number | null
    sellingPrice: number | null
    wholesalePrice: number | null
    stock: number | null
    unit: string | null
    minimumStock: number | null
    expiryDate: Date | null
    batchNumber: string | null
    manufacturer: string | null
    requiresPrescription: boolean | null
    activeIngredient: string | null
    dosage: string | null
    animalType: string | null
    nutritionInfo: string | null
    feedType: string | null
    primaryVendorId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    type: $Enums.ProductType | null
    category: string | null
    costPrice: number | null
    sellingPrice: number | null
    wholesalePrice: number | null
    stock: number | null
    unit: string | null
    minimumStock: number | null
    expiryDate: Date | null
    batchNumber: string | null
    manufacturer: string | null
    requiresPrescription: boolean | null
    activeIngredient: string | null
    dosage: string | null
    animalType: string | null
    nutritionInfo: string | null
    feedType: string | null
    primaryVendorId: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    type: number
    category: number
    costPrice: number
    sellingPrice: number
    wholesalePrice: number
    stock: number
    unit: number
    minimumStock: number
    expiryDate: number
    batchNumber: number
    manufacturer: number
    requiresPrescription: number
    activeIngredient: number
    dosage: number
    animalType: number
    nutritionInfo: number
    feedType: number
    primaryVendorId: number
    alternateVendors: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    stock?: true
    minimumStock?: true
  }

  export type ProductSumAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    stock?: true
    minimumStock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    category?: true
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    stock?: true
    unit?: true
    minimumStock?: true
    expiryDate?: true
    batchNumber?: true
    manufacturer?: true
    requiresPrescription?: true
    activeIngredient?: true
    dosage?: true
    animalType?: true
    nutritionInfo?: true
    feedType?: true
    primaryVendorId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    category?: true
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    stock?: true
    unit?: true
    minimumStock?: true
    expiryDate?: true
    batchNumber?: true
    manufacturer?: true
    requiresPrescription?: true
    activeIngredient?: true
    dosage?: true
    animalType?: true
    nutritionInfo?: true
    feedType?: true
    primaryVendorId?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    category?: true
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    stock?: true
    unit?: true
    minimumStock?: true
    expiryDate?: true
    batchNumber?: true
    manufacturer?: true
    requiresPrescription?: true
    activeIngredient?: true
    dosage?: true
    animalType?: true
    nutritionInfo?: true
    feedType?: true
    primaryVendorId?: true
    alternateVendors?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice: number | null
    stock: number
    unit: string
    minimumStock: number
    expiryDate: Date | null
    batchNumber: string | null
    manufacturer: string | null
    requiresPrescription: boolean
    activeIngredient: string | null
    dosage: string | null
    animalType: string | null
    nutritionInfo: string | null
    feedType: string | null
    primaryVendorId: string
    alternateVendors: JsonValue | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    stock?: boolean
    unit?: boolean
    minimumStock?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    manufacturer?: boolean
    requiresPrescription?: boolean
    activeIngredient?: boolean
    dosage?: boolean
    animalType?: boolean
    nutritionInfo?: boolean
    feedType?: boolean
    primaryVendorId?: boolean
    alternateVendors?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryVendor?: boolean | VendorDefaultArgs<ExtArgs>
    transactionItems?: boolean | Product$transactionItemsArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    stock?: boolean
    unit?: boolean
    minimumStock?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    manufacturer?: boolean
    requiresPrescription?: boolean
    activeIngredient?: boolean
    dosage?: boolean
    animalType?: boolean
    nutritionInfo?: boolean
    feedType?: boolean
    primaryVendorId?: boolean
    alternateVendors?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryVendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    stock?: boolean
    unit?: boolean
    minimumStock?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    manufacturer?: boolean
    requiresPrescription?: boolean
    activeIngredient?: boolean
    dosage?: boolean
    animalType?: boolean
    nutritionInfo?: boolean
    feedType?: boolean
    primaryVendorId?: boolean
    alternateVendors?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryVendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    stock?: boolean
    unit?: boolean
    minimumStock?: boolean
    expiryDate?: boolean
    batchNumber?: boolean
    manufacturer?: boolean
    requiresPrescription?: boolean
    activeIngredient?: boolean
    dosage?: boolean
    animalType?: boolean
    nutritionInfo?: boolean
    feedType?: boolean
    primaryVendorId?: boolean
    alternateVendors?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "description" | "type" | "category" | "costPrice" | "sellingPrice" | "wholesalePrice" | "stock" | "unit" | "minimumStock" | "expiryDate" | "batchNumber" | "manufacturer" | "requiresPrescription" | "activeIngredient" | "dosage" | "animalType" | "nutritionInfo" | "feedType" | "primaryVendorId" | "alternateVendors" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryVendor?: boolean | VendorDefaultArgs<ExtArgs>
    transactionItems?: boolean | Product$transactionItemsArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryVendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    primaryVendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      primaryVendor: Prisma.$VendorPayload<ExtArgs>
      transactionItems: Prisma.$TransactionItemPayload<ExtArgs>[]
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      type: $Enums.ProductType
      category: string
      costPrice: number
      sellingPrice: number
      wholesalePrice: number | null
      stock: number
      unit: string
      minimumStock: number
      expiryDate: Date | null
      batchNumber: string | null
      manufacturer: string | null
      requiresPrescription: boolean
      activeIngredient: string | null
      dosage: string | null
      animalType: string | null
      nutritionInfo: string | null
      feedType: string | null
      primaryVendorId: string
      alternateVendors: Prisma.JsonValue | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    primaryVendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactionItems<T extends Product$transactionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transactionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrderItems<T extends Product$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly category: FieldRef<"Product", 'String'>
    readonly costPrice: FieldRef<"Product", 'Float'>
    readonly sellingPrice: FieldRef<"Product", 'Float'>
    readonly wholesalePrice: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly minimumStock: FieldRef<"Product", 'Int'>
    readonly expiryDate: FieldRef<"Product", 'DateTime'>
    readonly batchNumber: FieldRef<"Product", 'String'>
    readonly manufacturer: FieldRef<"Product", 'String'>
    readonly requiresPrescription: FieldRef<"Product", 'Boolean'>
    readonly activeIngredient: FieldRef<"Product", 'String'>
    readonly dosage: FieldRef<"Product", 'String'>
    readonly animalType: FieldRef<"Product", 'String'>
    readonly nutritionInfo: FieldRef<"Product", 'String'>
    readonly feedType: FieldRef<"Product", 'String'>
    readonly primaryVendorId: FieldRef<"Product", 'String'>
    readonly alternateVendors: FieldRef<"Product", 'Json'>
    readonly active: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.transactionItems
   */
  export type Product$transactionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    cursor?: TransactionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * Product.purchaseOrderItems
   */
  export type Product$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paidAmount: number | null
    balanceAmount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paidAmount: number | null
    balanceAmount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    type: $Enums.TransactionType | null
    customerId: string | null
    vendorId: string | null
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paidAmount: number | null
    balanceAmount: number | null
    status: $Enums.TransactionStatus | null
    timestamp: Date | null
    dueDate: Date | null
    staffId: string | null
    notes: string | null
    synced: boolean | null
    cloudId: string | null
    syncError: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    type: $Enums.TransactionType | null
    customerId: string | null
    vendorId: string | null
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paidAmount: number | null
    balanceAmount: number | null
    status: $Enums.TransactionStatus | null
    timestamp: Date | null
    dueDate: Date | null
    staffId: string | null
    notes: string | null
    synced: boolean | null
    cloudId: string | null
    syncError: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    receiptNumber: number
    type: number
    customerId: number
    vendorId: number
    subtotal: number
    tax: number
    discount: number
    total: number
    paymentMethod: number
    paidAmount: number
    balanceAmount: number
    status: number
    timestamp: number
    dueDate: number
    staffId: number
    notes: number
    synced: number
    cloudId: number
    syncError: number
    lastSync: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balanceAmount?: true
  }

  export type TransactionSumAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paidAmount?: true
    balanceAmount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    receiptNumber?: true
    type?: true
    customerId?: true
    vendorId?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paymentMethod?: true
    paidAmount?: true
    balanceAmount?: true
    status?: true
    timestamp?: true
    dueDate?: true
    staffId?: true
    notes?: true
    synced?: true
    cloudId?: true
    syncError?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    receiptNumber?: true
    type?: true
    customerId?: true
    vendorId?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paymentMethod?: true
    paidAmount?: true
    balanceAmount?: true
    status?: true
    timestamp?: true
    dueDate?: true
    staffId?: true
    notes?: true
    synced?: true
    cloudId?: true
    syncError?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    receiptNumber?: true
    type?: true
    customerId?: true
    vendorId?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    paymentMethod?: true
    paidAmount?: true
    balanceAmount?: true
    status?: true
    timestamp?: true
    dueDate?: true
    staffId?: true
    notes?: true
    synced?: true
    cloudId?: true
    syncError?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId: string | null
    vendorId: string | null
    subtotal: number
    tax: number
    discount: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount: number
    balanceAmount: number
    status: $Enums.TransactionStatus
    timestamp: Date
    dueDate: Date | null
    staffId: string
    notes: string | null
    synced: boolean
    cloudId: string | null
    syncError: string | null
    lastSync: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    type?: boolean
    customerId?: boolean
    vendorId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    status?: boolean
    timestamp?: boolean
    dueDate?: boolean
    staffId?: boolean
    notes?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    vendor?: boolean | Transaction$vendorArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    items?: boolean | Transaction$itemsArgs<ExtArgs>
    paymentRecords?: boolean | Transaction$paymentRecordsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    type?: boolean
    customerId?: boolean
    vendorId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    status?: boolean
    timestamp?: boolean
    dueDate?: boolean
    staffId?: boolean
    notes?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    vendor?: boolean | Transaction$vendorArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    type?: boolean
    customerId?: boolean
    vendorId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    status?: boolean
    timestamp?: boolean
    dueDate?: boolean
    staffId?: boolean
    notes?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    vendor?: boolean | Transaction$vendorArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    receiptNumber?: boolean
    type?: boolean
    customerId?: boolean
    vendorId?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    balanceAmount?: boolean
    status?: boolean
    timestamp?: boolean
    dueDate?: boolean
    staffId?: boolean
    notes?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptNumber" | "type" | "customerId" | "vendorId" | "subtotal" | "tax" | "discount" | "total" | "paymentMethod" | "paidAmount" | "balanceAmount" | "status" | "timestamp" | "dueDate" | "staffId" | "notes" | "synced" | "cloudId" | "syncError" | "lastSync" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    vendor?: boolean | Transaction$vendorArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    items?: boolean | Transaction$itemsArgs<ExtArgs>
    paymentRecords?: boolean | Transaction$paymentRecordsArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    vendor?: boolean | Transaction$vendorArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    vendor?: boolean | Transaction$vendorArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs>
      items: Prisma.$TransactionItemPayload<ExtArgs>[]
      paymentRecords: Prisma.$PaymentRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptNumber: string
      type: $Enums.TransactionType
      customerId: string | null
      vendorId: string | null
      subtotal: number
      tax: number
      discount: number
      total: number
      paymentMethod: $Enums.PaymentMethod
      paidAmount: number
      balanceAmount: number
      status: $Enums.TransactionStatus
      timestamp: Date
      dueDate: Date | null
      staffId: string
      notes: string | null
      synced: boolean
      cloudId: string | null
      syncError: string | null
      lastSync: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Transaction$customerArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends Transaction$vendorArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Transaction$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentRecords<T extends Transaction$paymentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly receiptNumber: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly customerId: FieldRef<"Transaction", 'String'>
    readonly vendorId: FieldRef<"Transaction", 'String'>
    readonly subtotal: FieldRef<"Transaction", 'Float'>
    readonly tax: FieldRef<"Transaction", 'Float'>
    readonly discount: FieldRef<"Transaction", 'Float'>
    readonly total: FieldRef<"Transaction", 'Float'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly paidAmount: FieldRef<"Transaction", 'Float'>
    readonly balanceAmount: FieldRef<"Transaction", 'Float'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly timestamp: FieldRef<"Transaction", 'DateTime'>
    readonly dueDate: FieldRef<"Transaction", 'DateTime'>
    readonly staffId: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly synced: FieldRef<"Transaction", 'Boolean'>
    readonly cloudId: FieldRef<"Transaction", 'String'>
    readonly syncError: FieldRef<"Transaction", 'String'>
    readonly lastSync: FieldRef<"Transaction", 'DateTime'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.customer
   */
  export type Transaction$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Transaction.vendor
   */
  export type Transaction$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Transaction.items
   */
  export type Transaction$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    cursor?: TransactionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * Transaction.paymentRecords
   */
  export type Transaction$paymentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    where?: PaymentRecordWhereInput
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    cursor?: PaymentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionItem
   */

  export type AggregateTransactionItem = {
    _count: TransactionItemCountAggregateOutputType | null
    _avg: TransactionItemAvgAggregateOutputType | null
    _sum: TransactionItemSumAggregateOutputType | null
    _min: TransactionItemMinAggregateOutputType | null
    _max: TransactionItemMaxAggregateOutputType | null
  }

  export type TransactionItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type TransactionItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
  }

  export type TransactionItemMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    productName: string | null
    productSku: string | null
    unit: string | null
    batchNumber: string | null
    expiryDate: Date | null
    grade: string | null
  }

  export type TransactionItemMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    productName: string | null
    productSku: string | null
    unit: string | null
    batchNumber: string | null
    expiryDate: Date | null
    grade: string | null
  }

  export type TransactionItemCountAggregateOutputType = {
    id: number
    transactionId: number
    productId: number
    quantity: number
    unitPrice: number
    total: number
    productName: number
    productSku: number
    unit: number
    batchNumber: number
    expiryDate: number
    grade: number
    _all: number
  }


  export type TransactionItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type TransactionItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type TransactionItemMinAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    total?: true
    productName?: true
    productSku?: true
    unit?: true
    batchNumber?: true
    expiryDate?: true
    grade?: true
  }

  export type TransactionItemMaxAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    total?: true
    productName?: true
    productSku?: true
    unit?: true
    batchNumber?: true
    expiryDate?: true
    grade?: true
  }

  export type TransactionItemCountAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    total?: true
    productName?: true
    productSku?: true
    unit?: true
    batchNumber?: true
    expiryDate?: true
    grade?: true
    _all?: true
  }

  export type TransactionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionItem to aggregate.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionItems
    **/
    _count?: true | TransactionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionItemMaxAggregateInputType
  }

  export type GetTransactionItemAggregateType<T extends TransactionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionItem[P]>
      : GetScalarType<T[P], AggregateTransactionItem[P]>
  }




  export type TransactionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithAggregationInput | TransactionItemOrderByWithAggregationInput[]
    by: TransactionItemScalarFieldEnum[] | TransactionItemScalarFieldEnum
    having?: TransactionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionItemCountAggregateInputType | true
    _avg?: TransactionItemAvgAggregateInputType
    _sum?: TransactionItemSumAggregateInputType
    _min?: TransactionItemMinAggregateInputType
    _max?: TransactionItemMaxAggregateInputType
  }

  export type TransactionItemGroupByOutputType = {
    id: string
    transactionId: string
    productId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber: string | null
    expiryDate: Date | null
    grade: string | null
    _count: TransactionItemCountAggregateOutputType | null
    _avg: TransactionItemAvgAggregateOutputType | null
    _sum: TransactionItemSumAggregateOutputType | null
    _min: TransactionItemMinAggregateOutputType | null
    _max: TransactionItemMaxAggregateOutputType | null
  }

  type GetTransactionItemGroupByPayload<T extends TransactionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionItemGroupByOutputType[P]>
        }
      >
    >


  export type TransactionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    productSku?: boolean
    unit?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    grade?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>

  export type TransactionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    productSku?: boolean
    unit?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    grade?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>

  export type TransactionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    productSku?: boolean
    unit?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    grade?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>

  export type TransactionItemSelectScalar = {
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    productSku?: boolean
    unit?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    grade?: boolean
  }

  export type TransactionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "productId" | "quantity" | "unitPrice" | "total" | "productName" | "productSku" | "unit" | "batchNumber" | "expiryDate" | "grade", ExtArgs["result"]["transactionItem"]>
  export type TransactionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransactionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransactionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $TransactionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionItem"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      productId: string
      quantity: number
      unitPrice: number
      total: number
      productName: string
      productSku: string
      unit: string
      batchNumber: string | null
      expiryDate: Date | null
      grade: string | null
    }, ExtArgs["result"]["transactionItem"]>
    composites: {}
  }

  type TransactionItemGetPayload<S extends boolean | null | undefined | TransactionItemDefaultArgs> = $Result.GetResult<Prisma.$TransactionItemPayload, S>

  type TransactionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionItemCountAggregateInputType | true
    }

  export interface TransactionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionItem'], meta: { name: 'TransactionItem' } }
    /**
     * Find zero or one TransactionItem that matches the filter.
     * @param {TransactionItemFindUniqueArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionItemFindUniqueArgs>(args: SelectSubset<T, TransactionItemFindUniqueArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionItemFindUniqueOrThrowArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindFirstArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionItemFindFirstArgs>(args?: SelectSubset<T, TransactionItemFindFirstArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindFirstOrThrowArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionItems
     * const transactionItems = await prisma.transactionItem.findMany()
     * 
     * // Get first 10 TransactionItems
     * const transactionItems = await prisma.transactionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionItemFindManyArgs>(args?: SelectSubset<T, TransactionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionItem.
     * @param {TransactionItemCreateArgs} args - Arguments to create a TransactionItem.
     * @example
     * // Create one TransactionItem
     * const TransactionItem = await prisma.transactionItem.create({
     *   data: {
     *     // ... data to create a TransactionItem
     *   }
     * })
     * 
     */
    create<T extends TransactionItemCreateArgs>(args: SelectSubset<T, TransactionItemCreateArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionItems.
     * @param {TransactionItemCreateManyArgs} args - Arguments to create many TransactionItems.
     * @example
     * // Create many TransactionItems
     * const transactionItem = await prisma.transactionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionItemCreateManyArgs>(args?: SelectSubset<T, TransactionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionItems and returns the data saved in the database.
     * @param {TransactionItemCreateManyAndReturnArgs} args - Arguments to create many TransactionItems.
     * @example
     * // Create many TransactionItems
     * const transactionItem = await prisma.transactionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionItems and only return the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionItem.
     * @param {TransactionItemDeleteArgs} args - Arguments to delete one TransactionItem.
     * @example
     * // Delete one TransactionItem
     * const TransactionItem = await prisma.transactionItem.delete({
     *   where: {
     *     // ... filter to delete one TransactionItem
     *   }
     * })
     * 
     */
    delete<T extends TransactionItemDeleteArgs>(args: SelectSubset<T, TransactionItemDeleteArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionItem.
     * @param {TransactionItemUpdateArgs} args - Arguments to update one TransactionItem.
     * @example
     * // Update one TransactionItem
     * const transactionItem = await prisma.transactionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionItemUpdateArgs>(args: SelectSubset<T, TransactionItemUpdateArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionItems.
     * @param {TransactionItemDeleteManyArgs} args - Arguments to filter TransactionItems to delete.
     * @example
     * // Delete a few TransactionItems
     * const { count } = await prisma.transactionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionItemDeleteManyArgs>(args?: SelectSubset<T, TransactionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionItems
     * const transactionItem = await prisma.transactionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionItemUpdateManyArgs>(args: SelectSubset<T, TransactionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionItems and returns the data updated in the database.
     * @param {TransactionItemUpdateManyAndReturnArgs} args - Arguments to update many TransactionItems.
     * @example
     * // Update many TransactionItems
     * const transactionItem = await prisma.transactionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionItems and only return the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionItem.
     * @param {TransactionItemUpsertArgs} args - Arguments to update or create a TransactionItem.
     * @example
     * // Update or create a TransactionItem
     * const transactionItem = await prisma.transactionItem.upsert({
     *   create: {
     *     // ... data to create a TransactionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionItem we want to update
     *   }
     * })
     */
    upsert<T extends TransactionItemUpsertArgs>(args: SelectSubset<T, TransactionItemUpsertArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemCountArgs} args - Arguments to filter TransactionItems to count.
     * @example
     * // Count the number of TransactionItems
     * const count = await prisma.transactionItem.count({
     *   where: {
     *     // ... the filter for the TransactionItems we want to count
     *   }
     * })
    **/
    count<T extends TransactionItemCountArgs>(
      args?: Subset<T, TransactionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionItemAggregateArgs>(args: Subset<T, TransactionItemAggregateArgs>): Prisma.PrismaPromise<GetTransactionItemAggregateType<T>>

    /**
     * Group by TransactionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionItemGroupByArgs['orderBy'] }
        : { orderBy?: TransactionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionItem model
   */
  readonly fields: TransactionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionItem model
   */
  interface TransactionItemFieldRefs {
    readonly id: FieldRef<"TransactionItem", 'String'>
    readonly transactionId: FieldRef<"TransactionItem", 'String'>
    readonly productId: FieldRef<"TransactionItem", 'String'>
    readonly quantity: FieldRef<"TransactionItem", 'Int'>
    readonly unitPrice: FieldRef<"TransactionItem", 'Int'>
    readonly total: FieldRef<"TransactionItem", 'Int'>
    readonly productName: FieldRef<"TransactionItem", 'String'>
    readonly productSku: FieldRef<"TransactionItem", 'String'>
    readonly unit: FieldRef<"TransactionItem", 'String'>
    readonly batchNumber: FieldRef<"TransactionItem", 'String'>
    readonly expiryDate: FieldRef<"TransactionItem", 'DateTime'>
    readonly grade: FieldRef<"TransactionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransactionItem findUnique
   */
  export type TransactionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem findUniqueOrThrow
   */
  export type TransactionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem findFirst
   */
  export type TransactionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionItems.
     */
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem findFirstOrThrow
   */
  export type TransactionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionItems.
     */
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem findMany
   */
  export type TransactionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItems to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem create
   */
  export type TransactionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionItem.
     */
    data: XOR<TransactionItemCreateInput, TransactionItemUncheckedCreateInput>
  }

  /**
   * TransactionItem createMany
   */
  export type TransactionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionItems.
     */
    data: TransactionItemCreateManyInput | TransactionItemCreateManyInput[]
  }

  /**
   * TransactionItem createManyAndReturn
   */
  export type TransactionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionItems.
     */
    data: TransactionItemCreateManyInput | TransactionItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionItem update
   */
  export type TransactionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionItem.
     */
    data: XOR<TransactionItemUpdateInput, TransactionItemUncheckedUpdateInput>
    /**
     * Choose, which TransactionItem to update.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem updateMany
   */
  export type TransactionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionItems.
     */
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyInput>
    /**
     * Filter which TransactionItems to update
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to update.
     */
    limit?: number
  }

  /**
   * TransactionItem updateManyAndReturn
   */
  export type TransactionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * The data used to update TransactionItems.
     */
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyInput>
    /**
     * Filter which TransactionItems to update
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionItem upsert
   */
  export type TransactionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionItem to update in case it exists.
     */
    where: TransactionItemWhereUniqueInput
    /**
     * In case the TransactionItem found by the `where` argument doesn't exist, create a new TransactionItem with this data.
     */
    create: XOR<TransactionItemCreateInput, TransactionItemUncheckedCreateInput>
    /**
     * In case the TransactionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionItemUpdateInput, TransactionItemUncheckedUpdateInput>
  }

  /**
   * TransactionItem delete
   */
  export type TransactionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter which TransactionItem to delete.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem deleteMany
   */
  export type TransactionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionItems to delete
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to delete.
     */
    limit?: number
  }

  /**
   * TransactionItem without action
   */
  export type TransactionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
  }


  /**
   * Model EggCollection
   */

  export type AggregateEggCollection = {
    _count: EggCollectionCountAggregateOutputType | null
    _avg: EggCollectionAvgAggregateOutputType | null
    _sum: EggCollectionSumAggregateOutputType | null
    _min: EggCollectionMinAggregateOutputType | null
    _max: EggCollectionMaxAggregateOutputType | null
  }

  export type EggCollectionAvgAggregateOutputType = {
    henEggsSmall: number | null
    henEggsMedium: number | null
    henEggsLarge: number | null
    henEggsExtraLarge: number | null
    henEggsDamaged: number | null
    totalHenEggs: number | null
    duckEggsSmall: number | null
    duckEggsMedium: number | null
    duckEggsLarge: number | null
    duckEggsDamaged: number | null
    totalDuckEggs: number | null
    henEggPrice: number | null
    duckEggPrice: number | null
    totalValue: number | null
    qualityScore: number | null
  }

  export type EggCollectionSumAggregateOutputType = {
    henEggsSmall: number | null
    henEggsMedium: number | null
    henEggsLarge: number | null
    henEggsExtraLarge: number | null
    henEggsDamaged: number | null
    totalHenEggs: number | null
    duckEggsSmall: number | null
    duckEggsMedium: number | null
    duckEggsLarge: number | null
    duckEggsDamaged: number | null
    totalDuckEggs: number | null
    henEggPrice: number | null
    duckEggPrice: number | null
    totalValue: number | null
    qualityScore: number | null
  }

  export type EggCollectionMinAggregateOutputType = {
    id: string | null
    farmerId: string | null
    routeId: string | null
    staffId: string | null
    collectionDate: Date | null
    henEggsSmall: number | null
    henEggsMedium: number | null
    henEggsLarge: number | null
    henEggsExtraLarge: number | null
    henEggsDamaged: number | null
    totalHenEggs: number | null
    duckEggsSmall: number | null
    duckEggsMedium: number | null
    duckEggsLarge: number | null
    duckEggsDamaged: number | null
    totalDuckEggs: number | null
    henEggPrice: number | null
    duckEggPrice: number | null
    totalValue: number | null
    qualityScore: number | null
    qualityNotes: string | null
    paid: boolean | null
    paymentDate: Date | null
    synced: boolean | null
    cloudId: string | null
    syncError: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EggCollectionMaxAggregateOutputType = {
    id: string | null
    farmerId: string | null
    routeId: string | null
    staffId: string | null
    collectionDate: Date | null
    henEggsSmall: number | null
    henEggsMedium: number | null
    henEggsLarge: number | null
    henEggsExtraLarge: number | null
    henEggsDamaged: number | null
    totalHenEggs: number | null
    duckEggsSmall: number | null
    duckEggsMedium: number | null
    duckEggsLarge: number | null
    duckEggsDamaged: number | null
    totalDuckEggs: number | null
    henEggPrice: number | null
    duckEggPrice: number | null
    totalValue: number | null
    qualityScore: number | null
    qualityNotes: string | null
    paid: boolean | null
    paymentDate: Date | null
    synced: boolean | null
    cloudId: string | null
    syncError: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EggCollectionCountAggregateOutputType = {
    id: number
    farmerId: number
    routeId: number
    staffId: number
    collectionDate: number
    henEggsSmall: number
    henEggsMedium: number
    henEggsLarge: number
    henEggsExtraLarge: number
    henEggsDamaged: number
    totalHenEggs: number
    duckEggsSmall: number
    duckEggsMedium: number
    duckEggsLarge: number
    duckEggsDamaged: number
    totalDuckEggs: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore: number
    qualityNotes: number
    paid: number
    paymentDate: number
    synced: number
    cloudId: number
    syncError: number
    lastSync: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EggCollectionAvgAggregateInputType = {
    henEggsSmall?: true
    henEggsMedium?: true
    henEggsLarge?: true
    henEggsExtraLarge?: true
    henEggsDamaged?: true
    totalHenEggs?: true
    duckEggsSmall?: true
    duckEggsMedium?: true
    duckEggsLarge?: true
    duckEggsDamaged?: true
    totalDuckEggs?: true
    henEggPrice?: true
    duckEggPrice?: true
    totalValue?: true
    qualityScore?: true
  }

  export type EggCollectionSumAggregateInputType = {
    henEggsSmall?: true
    henEggsMedium?: true
    henEggsLarge?: true
    henEggsExtraLarge?: true
    henEggsDamaged?: true
    totalHenEggs?: true
    duckEggsSmall?: true
    duckEggsMedium?: true
    duckEggsLarge?: true
    duckEggsDamaged?: true
    totalDuckEggs?: true
    henEggPrice?: true
    duckEggPrice?: true
    totalValue?: true
    qualityScore?: true
  }

  export type EggCollectionMinAggregateInputType = {
    id?: true
    farmerId?: true
    routeId?: true
    staffId?: true
    collectionDate?: true
    henEggsSmall?: true
    henEggsMedium?: true
    henEggsLarge?: true
    henEggsExtraLarge?: true
    henEggsDamaged?: true
    totalHenEggs?: true
    duckEggsSmall?: true
    duckEggsMedium?: true
    duckEggsLarge?: true
    duckEggsDamaged?: true
    totalDuckEggs?: true
    henEggPrice?: true
    duckEggPrice?: true
    totalValue?: true
    qualityScore?: true
    qualityNotes?: true
    paid?: true
    paymentDate?: true
    synced?: true
    cloudId?: true
    syncError?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EggCollectionMaxAggregateInputType = {
    id?: true
    farmerId?: true
    routeId?: true
    staffId?: true
    collectionDate?: true
    henEggsSmall?: true
    henEggsMedium?: true
    henEggsLarge?: true
    henEggsExtraLarge?: true
    henEggsDamaged?: true
    totalHenEggs?: true
    duckEggsSmall?: true
    duckEggsMedium?: true
    duckEggsLarge?: true
    duckEggsDamaged?: true
    totalDuckEggs?: true
    henEggPrice?: true
    duckEggPrice?: true
    totalValue?: true
    qualityScore?: true
    qualityNotes?: true
    paid?: true
    paymentDate?: true
    synced?: true
    cloudId?: true
    syncError?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EggCollectionCountAggregateInputType = {
    id?: true
    farmerId?: true
    routeId?: true
    staffId?: true
    collectionDate?: true
    henEggsSmall?: true
    henEggsMedium?: true
    henEggsLarge?: true
    henEggsExtraLarge?: true
    henEggsDamaged?: true
    totalHenEggs?: true
    duckEggsSmall?: true
    duckEggsMedium?: true
    duckEggsLarge?: true
    duckEggsDamaged?: true
    totalDuckEggs?: true
    henEggPrice?: true
    duckEggPrice?: true
    totalValue?: true
    qualityScore?: true
    qualityNotes?: true
    paid?: true
    paymentDate?: true
    synced?: true
    cloudId?: true
    syncError?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EggCollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EggCollection to aggregate.
     */
    where?: EggCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggCollections to fetch.
     */
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EggCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EggCollections
    **/
    _count?: true | EggCollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EggCollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EggCollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EggCollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EggCollectionMaxAggregateInputType
  }

  export type GetEggCollectionAggregateType<T extends EggCollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateEggCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEggCollection[P]>
      : GetScalarType<T[P], AggregateEggCollection[P]>
  }




  export type EggCollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggCollectionWhereInput
    orderBy?: EggCollectionOrderByWithAggregationInput | EggCollectionOrderByWithAggregationInput[]
    by: EggCollectionScalarFieldEnum[] | EggCollectionScalarFieldEnum
    having?: EggCollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EggCollectionCountAggregateInputType | true
    _avg?: EggCollectionAvgAggregateInputType
    _sum?: EggCollectionSumAggregateInputType
    _min?: EggCollectionMinAggregateInputType
    _max?: EggCollectionMaxAggregateInputType
  }

  export type EggCollectionGroupByOutputType = {
    id: string
    farmerId: string
    routeId: string | null
    staffId: string
    collectionDate: Date
    henEggsSmall: number
    henEggsMedium: number
    henEggsLarge: number
    henEggsExtraLarge: number
    henEggsDamaged: number
    totalHenEggs: number
    duckEggsSmall: number
    duckEggsMedium: number
    duckEggsLarge: number
    duckEggsDamaged: number
    totalDuckEggs: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore: number | null
    qualityNotes: string | null
    paid: boolean
    paymentDate: Date | null
    synced: boolean
    cloudId: string | null
    syncError: string | null
    lastSync: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EggCollectionCountAggregateOutputType | null
    _avg: EggCollectionAvgAggregateOutputType | null
    _sum: EggCollectionSumAggregateOutputType | null
    _min: EggCollectionMinAggregateOutputType | null
    _max: EggCollectionMaxAggregateOutputType | null
  }

  type GetEggCollectionGroupByPayload<T extends EggCollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EggCollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EggCollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EggCollectionGroupByOutputType[P]>
            : GetScalarType<T[P], EggCollectionGroupByOutputType[P]>
        }
      >
    >


  export type EggCollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farmerId?: boolean
    routeId?: boolean
    staffId?: boolean
    collectionDate?: boolean
    henEggsSmall?: boolean
    henEggsMedium?: boolean
    henEggsLarge?: boolean
    henEggsExtraLarge?: boolean
    henEggsDamaged?: boolean
    totalHenEggs?: boolean
    duckEggsSmall?: boolean
    duckEggsMedium?: boolean
    duckEggsLarge?: boolean
    duckEggsDamaged?: boolean
    totalDuckEggs?: boolean
    henEggPrice?: boolean
    duckEggPrice?: boolean
    totalValue?: boolean
    qualityScore?: boolean
    qualityNotes?: boolean
    paid?: boolean
    paymentDate?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | CustomerDefaultArgs<ExtArgs>
    route?: boolean | EggCollection$routeArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggCollection"]>

  export type EggCollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farmerId?: boolean
    routeId?: boolean
    staffId?: boolean
    collectionDate?: boolean
    henEggsSmall?: boolean
    henEggsMedium?: boolean
    henEggsLarge?: boolean
    henEggsExtraLarge?: boolean
    henEggsDamaged?: boolean
    totalHenEggs?: boolean
    duckEggsSmall?: boolean
    duckEggsMedium?: boolean
    duckEggsLarge?: boolean
    duckEggsDamaged?: boolean
    totalDuckEggs?: boolean
    henEggPrice?: boolean
    duckEggPrice?: boolean
    totalValue?: boolean
    qualityScore?: boolean
    qualityNotes?: boolean
    paid?: boolean
    paymentDate?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | CustomerDefaultArgs<ExtArgs>
    route?: boolean | EggCollection$routeArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggCollection"]>

  export type EggCollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    farmerId?: boolean
    routeId?: boolean
    staffId?: boolean
    collectionDate?: boolean
    henEggsSmall?: boolean
    henEggsMedium?: boolean
    henEggsLarge?: boolean
    henEggsExtraLarge?: boolean
    henEggsDamaged?: boolean
    totalHenEggs?: boolean
    duckEggsSmall?: boolean
    duckEggsMedium?: boolean
    duckEggsLarge?: boolean
    duckEggsDamaged?: boolean
    totalDuckEggs?: boolean
    henEggPrice?: boolean
    duckEggPrice?: boolean
    totalValue?: boolean
    qualityScore?: boolean
    qualityNotes?: boolean
    paid?: boolean
    paymentDate?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    farmer?: boolean | CustomerDefaultArgs<ExtArgs>
    route?: boolean | EggCollection$routeArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggCollection"]>

  export type EggCollectionSelectScalar = {
    id?: boolean
    farmerId?: boolean
    routeId?: boolean
    staffId?: boolean
    collectionDate?: boolean
    henEggsSmall?: boolean
    henEggsMedium?: boolean
    henEggsLarge?: boolean
    henEggsExtraLarge?: boolean
    henEggsDamaged?: boolean
    totalHenEggs?: boolean
    duckEggsSmall?: boolean
    duckEggsMedium?: boolean
    duckEggsLarge?: boolean
    duckEggsDamaged?: boolean
    totalDuckEggs?: boolean
    henEggPrice?: boolean
    duckEggPrice?: boolean
    totalValue?: boolean
    qualityScore?: boolean
    qualityNotes?: boolean
    paid?: boolean
    paymentDate?: boolean
    synced?: boolean
    cloudId?: boolean
    syncError?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EggCollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "farmerId" | "routeId" | "staffId" | "collectionDate" | "henEggsSmall" | "henEggsMedium" | "henEggsLarge" | "henEggsExtraLarge" | "henEggsDamaged" | "totalHenEggs" | "duckEggsSmall" | "duckEggsMedium" | "duckEggsLarge" | "duckEggsDamaged" | "totalDuckEggs" | "henEggPrice" | "duckEggPrice" | "totalValue" | "qualityScore" | "qualityNotes" | "paid" | "paymentDate" | "synced" | "cloudId" | "syncError" | "lastSync" | "createdAt" | "updatedAt", ExtArgs["result"]["eggCollection"]>
  export type EggCollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | CustomerDefaultArgs<ExtArgs>
    route?: boolean | EggCollection$routeArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type EggCollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | CustomerDefaultArgs<ExtArgs>
    route?: boolean | EggCollection$routeArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type EggCollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    farmer?: boolean | CustomerDefaultArgs<ExtArgs>
    route?: boolean | EggCollection$routeArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $EggCollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EggCollection"
    objects: {
      farmer: Prisma.$CustomerPayload<ExtArgs>
      route: Prisma.$CollectionRoutePayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      farmerId: string
      routeId: string | null
      staffId: string
      collectionDate: Date
      henEggsSmall: number
      henEggsMedium: number
      henEggsLarge: number
      henEggsExtraLarge: number
      henEggsDamaged: number
      totalHenEggs: number
      duckEggsSmall: number
      duckEggsMedium: number
      duckEggsLarge: number
      duckEggsDamaged: number
      totalDuckEggs: number
      henEggPrice: number
      duckEggPrice: number
      totalValue: number
      qualityScore: number | null
      qualityNotes: string | null
      paid: boolean
      paymentDate: Date | null
      synced: boolean
      cloudId: string | null
      syncError: string | null
      lastSync: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eggCollection"]>
    composites: {}
  }

  type EggCollectionGetPayload<S extends boolean | null | undefined | EggCollectionDefaultArgs> = $Result.GetResult<Prisma.$EggCollectionPayload, S>

  type EggCollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EggCollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EggCollectionCountAggregateInputType | true
    }

  export interface EggCollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EggCollection'], meta: { name: 'EggCollection' } }
    /**
     * Find zero or one EggCollection that matches the filter.
     * @param {EggCollectionFindUniqueArgs} args - Arguments to find a EggCollection
     * @example
     * // Get one EggCollection
     * const eggCollection = await prisma.eggCollection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EggCollectionFindUniqueArgs>(args: SelectSubset<T, EggCollectionFindUniqueArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EggCollection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EggCollectionFindUniqueOrThrowArgs} args - Arguments to find a EggCollection
     * @example
     * // Get one EggCollection
     * const eggCollection = await prisma.eggCollection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EggCollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, EggCollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EggCollection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionFindFirstArgs} args - Arguments to find a EggCollection
     * @example
     * // Get one EggCollection
     * const eggCollection = await prisma.eggCollection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EggCollectionFindFirstArgs>(args?: SelectSubset<T, EggCollectionFindFirstArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EggCollection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionFindFirstOrThrowArgs} args - Arguments to find a EggCollection
     * @example
     * // Get one EggCollection
     * const eggCollection = await prisma.eggCollection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EggCollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, EggCollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EggCollections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EggCollections
     * const eggCollections = await prisma.eggCollection.findMany()
     * 
     * // Get first 10 EggCollections
     * const eggCollections = await prisma.eggCollection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eggCollectionWithIdOnly = await prisma.eggCollection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EggCollectionFindManyArgs>(args?: SelectSubset<T, EggCollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EggCollection.
     * @param {EggCollectionCreateArgs} args - Arguments to create a EggCollection.
     * @example
     * // Create one EggCollection
     * const EggCollection = await prisma.eggCollection.create({
     *   data: {
     *     // ... data to create a EggCollection
     *   }
     * })
     * 
     */
    create<T extends EggCollectionCreateArgs>(args: SelectSubset<T, EggCollectionCreateArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EggCollections.
     * @param {EggCollectionCreateManyArgs} args - Arguments to create many EggCollections.
     * @example
     * // Create many EggCollections
     * const eggCollection = await prisma.eggCollection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EggCollectionCreateManyArgs>(args?: SelectSubset<T, EggCollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EggCollections and returns the data saved in the database.
     * @param {EggCollectionCreateManyAndReturnArgs} args - Arguments to create many EggCollections.
     * @example
     * // Create many EggCollections
     * const eggCollection = await prisma.eggCollection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EggCollections and only return the `id`
     * const eggCollectionWithIdOnly = await prisma.eggCollection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EggCollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, EggCollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EggCollection.
     * @param {EggCollectionDeleteArgs} args - Arguments to delete one EggCollection.
     * @example
     * // Delete one EggCollection
     * const EggCollection = await prisma.eggCollection.delete({
     *   where: {
     *     // ... filter to delete one EggCollection
     *   }
     * })
     * 
     */
    delete<T extends EggCollectionDeleteArgs>(args: SelectSubset<T, EggCollectionDeleteArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EggCollection.
     * @param {EggCollectionUpdateArgs} args - Arguments to update one EggCollection.
     * @example
     * // Update one EggCollection
     * const eggCollection = await prisma.eggCollection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EggCollectionUpdateArgs>(args: SelectSubset<T, EggCollectionUpdateArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EggCollections.
     * @param {EggCollectionDeleteManyArgs} args - Arguments to filter EggCollections to delete.
     * @example
     * // Delete a few EggCollections
     * const { count } = await prisma.eggCollection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EggCollectionDeleteManyArgs>(args?: SelectSubset<T, EggCollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EggCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EggCollections
     * const eggCollection = await prisma.eggCollection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EggCollectionUpdateManyArgs>(args: SelectSubset<T, EggCollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EggCollections and returns the data updated in the database.
     * @param {EggCollectionUpdateManyAndReturnArgs} args - Arguments to update many EggCollections.
     * @example
     * // Update many EggCollections
     * const eggCollection = await prisma.eggCollection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EggCollections and only return the `id`
     * const eggCollectionWithIdOnly = await prisma.eggCollection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EggCollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, EggCollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EggCollection.
     * @param {EggCollectionUpsertArgs} args - Arguments to update or create a EggCollection.
     * @example
     * // Update or create a EggCollection
     * const eggCollection = await prisma.eggCollection.upsert({
     *   create: {
     *     // ... data to create a EggCollection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EggCollection we want to update
     *   }
     * })
     */
    upsert<T extends EggCollectionUpsertArgs>(args: SelectSubset<T, EggCollectionUpsertArgs<ExtArgs>>): Prisma__EggCollectionClient<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EggCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionCountArgs} args - Arguments to filter EggCollections to count.
     * @example
     * // Count the number of EggCollections
     * const count = await prisma.eggCollection.count({
     *   where: {
     *     // ... the filter for the EggCollections we want to count
     *   }
     * })
    **/
    count<T extends EggCollectionCountArgs>(
      args?: Subset<T, EggCollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EggCollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EggCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EggCollectionAggregateArgs>(args: Subset<T, EggCollectionAggregateArgs>): Prisma.PrismaPromise<GetEggCollectionAggregateType<T>>

    /**
     * Group by EggCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggCollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EggCollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EggCollectionGroupByArgs['orderBy'] }
        : { orderBy?: EggCollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EggCollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEggCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EggCollection model
   */
  readonly fields: EggCollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EggCollection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EggCollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    farmer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends EggCollection$routeArgs<ExtArgs> = {}>(args?: Subset<T, EggCollection$routeArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EggCollection model
   */
  interface EggCollectionFieldRefs {
    readonly id: FieldRef<"EggCollection", 'String'>
    readonly farmerId: FieldRef<"EggCollection", 'String'>
    readonly routeId: FieldRef<"EggCollection", 'String'>
    readonly staffId: FieldRef<"EggCollection", 'String'>
    readonly collectionDate: FieldRef<"EggCollection", 'DateTime'>
    readonly henEggsSmall: FieldRef<"EggCollection", 'Int'>
    readonly henEggsMedium: FieldRef<"EggCollection", 'Int'>
    readonly henEggsLarge: FieldRef<"EggCollection", 'Int'>
    readonly henEggsExtraLarge: FieldRef<"EggCollection", 'Int'>
    readonly henEggsDamaged: FieldRef<"EggCollection", 'Int'>
    readonly totalHenEggs: FieldRef<"EggCollection", 'Int'>
    readonly duckEggsSmall: FieldRef<"EggCollection", 'Int'>
    readonly duckEggsMedium: FieldRef<"EggCollection", 'Int'>
    readonly duckEggsLarge: FieldRef<"EggCollection", 'Int'>
    readonly duckEggsDamaged: FieldRef<"EggCollection", 'Int'>
    readonly totalDuckEggs: FieldRef<"EggCollection", 'Int'>
    readonly henEggPrice: FieldRef<"EggCollection", 'Float'>
    readonly duckEggPrice: FieldRef<"EggCollection", 'Float'>
    readonly totalValue: FieldRef<"EggCollection", 'Float'>
    readonly qualityScore: FieldRef<"EggCollection", 'Float'>
    readonly qualityNotes: FieldRef<"EggCollection", 'String'>
    readonly paid: FieldRef<"EggCollection", 'Boolean'>
    readonly paymentDate: FieldRef<"EggCollection", 'DateTime'>
    readonly synced: FieldRef<"EggCollection", 'Boolean'>
    readonly cloudId: FieldRef<"EggCollection", 'String'>
    readonly syncError: FieldRef<"EggCollection", 'String'>
    readonly lastSync: FieldRef<"EggCollection", 'DateTime'>
    readonly createdAt: FieldRef<"EggCollection", 'DateTime'>
    readonly updatedAt: FieldRef<"EggCollection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EggCollection findUnique
   */
  export type EggCollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * Filter, which EggCollection to fetch.
     */
    where: EggCollectionWhereUniqueInput
  }

  /**
   * EggCollection findUniqueOrThrow
   */
  export type EggCollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * Filter, which EggCollection to fetch.
     */
    where: EggCollectionWhereUniqueInput
  }

  /**
   * EggCollection findFirst
   */
  export type EggCollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * Filter, which EggCollection to fetch.
     */
    where?: EggCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggCollections to fetch.
     */
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EggCollections.
     */
    cursor?: EggCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EggCollections.
     */
    distinct?: EggCollectionScalarFieldEnum | EggCollectionScalarFieldEnum[]
  }

  /**
   * EggCollection findFirstOrThrow
   */
  export type EggCollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * Filter, which EggCollection to fetch.
     */
    where?: EggCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggCollections to fetch.
     */
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EggCollections.
     */
    cursor?: EggCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EggCollections.
     */
    distinct?: EggCollectionScalarFieldEnum | EggCollectionScalarFieldEnum[]
  }

  /**
   * EggCollection findMany
   */
  export type EggCollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * Filter, which EggCollections to fetch.
     */
    where?: EggCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggCollections to fetch.
     */
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EggCollections.
     */
    cursor?: EggCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggCollections.
     */
    skip?: number
    distinct?: EggCollectionScalarFieldEnum | EggCollectionScalarFieldEnum[]
  }

  /**
   * EggCollection create
   */
  export type EggCollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a EggCollection.
     */
    data: XOR<EggCollectionCreateInput, EggCollectionUncheckedCreateInput>
  }

  /**
   * EggCollection createMany
   */
  export type EggCollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EggCollections.
     */
    data: EggCollectionCreateManyInput | EggCollectionCreateManyInput[]
  }

  /**
   * EggCollection createManyAndReturn
   */
  export type EggCollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * The data used to create many EggCollections.
     */
    data: EggCollectionCreateManyInput | EggCollectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EggCollection update
   */
  export type EggCollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a EggCollection.
     */
    data: XOR<EggCollectionUpdateInput, EggCollectionUncheckedUpdateInput>
    /**
     * Choose, which EggCollection to update.
     */
    where: EggCollectionWhereUniqueInput
  }

  /**
   * EggCollection updateMany
   */
  export type EggCollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EggCollections.
     */
    data: XOR<EggCollectionUpdateManyMutationInput, EggCollectionUncheckedUpdateManyInput>
    /**
     * Filter which EggCollections to update
     */
    where?: EggCollectionWhereInput
    /**
     * Limit how many EggCollections to update.
     */
    limit?: number
  }

  /**
   * EggCollection updateManyAndReturn
   */
  export type EggCollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * The data used to update EggCollections.
     */
    data: XOR<EggCollectionUpdateManyMutationInput, EggCollectionUncheckedUpdateManyInput>
    /**
     * Filter which EggCollections to update
     */
    where?: EggCollectionWhereInput
    /**
     * Limit how many EggCollections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EggCollection upsert
   */
  export type EggCollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the EggCollection to update in case it exists.
     */
    where: EggCollectionWhereUniqueInput
    /**
     * In case the EggCollection found by the `where` argument doesn't exist, create a new EggCollection with this data.
     */
    create: XOR<EggCollectionCreateInput, EggCollectionUncheckedCreateInput>
    /**
     * In case the EggCollection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EggCollectionUpdateInput, EggCollectionUncheckedUpdateInput>
  }

  /**
   * EggCollection delete
   */
  export type EggCollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    /**
     * Filter which EggCollection to delete.
     */
    where: EggCollectionWhereUniqueInput
  }

  /**
   * EggCollection deleteMany
   */
  export type EggCollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EggCollections to delete
     */
    where?: EggCollectionWhereInput
    /**
     * Limit how many EggCollections to delete.
     */
    limit?: number
  }

  /**
   * EggCollection.route
   */
  export type EggCollection$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    where?: CollectionRouteWhereInput
  }

  /**
   * EggCollection without action
   */
  export type EggCollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
  }


  /**
   * Model CollectionRoute
   */

  export type AggregateCollectionRoute = {
    _count: CollectionRouteCountAggregateOutputType | null
    _avg: CollectionRouteAvgAggregateOutputType | null
    _sum: CollectionRouteSumAggregateOutputType | null
    _min: CollectionRouteMinAggregateOutputType | null
    _max: CollectionRouteMaxAggregateOutputType | null
  }

  export type CollectionRouteAvgAggregateOutputType = {
    estimatedTime: number | null
    estimatedDistance: number | null
    averageTime: number | null
    onTimePercentage: number | null
    totalCollections: number | null
  }

  export type CollectionRouteSumAggregateOutputType = {
    estimatedTime: number | null
    estimatedDistance: number | null
    averageTime: number | null
    onTimePercentage: number | null
    totalCollections: number | null
  }

  export type CollectionRouteMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    estimatedTime: number | null
    estimatedDistance: number | null
    schedule: $Enums.CollectionSchedule | null
    staffId: string | null
    averageTime: number | null
    onTimePercentage: number | null
    totalCollections: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionRouteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    estimatedTime: number | null
    estimatedDistance: number | null
    schedule: $Enums.CollectionSchedule | null
    staffId: string | null
    averageTime: number | null
    onTimePercentage: number | null
    totalCollections: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionRouteCountAggregateOutputType = {
    id: number
    name: number
    description: number
    estimatedTime: number
    estimatedDistance: number
    schedule: number
    staffId: number
    averageTime: number
    onTimePercentage: number
    totalCollections: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionRouteAvgAggregateInputType = {
    estimatedTime?: true
    estimatedDistance?: true
    averageTime?: true
    onTimePercentage?: true
    totalCollections?: true
  }

  export type CollectionRouteSumAggregateInputType = {
    estimatedTime?: true
    estimatedDistance?: true
    averageTime?: true
    onTimePercentage?: true
    totalCollections?: true
  }

  export type CollectionRouteMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    estimatedTime?: true
    estimatedDistance?: true
    schedule?: true
    staffId?: true
    averageTime?: true
    onTimePercentage?: true
    totalCollections?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionRouteMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    estimatedTime?: true
    estimatedDistance?: true
    schedule?: true
    staffId?: true
    averageTime?: true
    onTimePercentage?: true
    totalCollections?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionRouteCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    estimatedTime?: true
    estimatedDistance?: true
    schedule?: true
    staffId?: true
    averageTime?: true
    onTimePercentage?: true
    totalCollections?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionRoute to aggregate.
     */
    where?: CollectionRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionRoutes to fetch.
     */
    orderBy?: CollectionRouteOrderByWithRelationInput | CollectionRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionRoutes
    **/
    _count?: true | CollectionRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionRouteMaxAggregateInputType
  }

  export type GetCollectionRouteAggregateType<T extends CollectionRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionRoute[P]>
      : GetScalarType<T[P], AggregateCollectionRoute[P]>
  }




  export type CollectionRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionRouteWhereInput
    orderBy?: CollectionRouteOrderByWithAggregationInput | CollectionRouteOrderByWithAggregationInput[]
    by: CollectionRouteScalarFieldEnum[] | CollectionRouteScalarFieldEnum
    having?: CollectionRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionRouteCountAggregateInputType | true
    _avg?: CollectionRouteAvgAggregateInputType
    _sum?: CollectionRouteSumAggregateInputType
    _min?: CollectionRouteMinAggregateInputType
    _max?: CollectionRouteMaxAggregateInputType
  }

  export type CollectionRouteGroupByOutputType = {
    id: string
    name: string
    description: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule: $Enums.CollectionSchedule
    staffId: string | null
    averageTime: number | null
    onTimePercentage: number | null
    totalCollections: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollectionRouteCountAggregateOutputType | null
    _avg: CollectionRouteAvgAggregateOutputType | null
    _sum: CollectionRouteSumAggregateOutputType | null
    _min: CollectionRouteMinAggregateOutputType | null
    _max: CollectionRouteMaxAggregateOutputType | null
  }

  type GetCollectionRouteGroupByPayload<T extends CollectionRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionRouteGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionRouteGroupByOutputType[P]>
        }
      >
    >


  export type CollectionRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    estimatedTime?: boolean
    estimatedDistance?: boolean
    schedule?: boolean
    staffId?: boolean
    averageTime?: boolean
    onTimePercentage?: boolean
    totalCollections?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | CollectionRoute$staffArgs<ExtArgs>
    customers?: boolean | CollectionRoute$customersArgs<ExtArgs>
    eggCollections?: boolean | CollectionRoute$eggCollectionsArgs<ExtArgs>
    _count?: boolean | CollectionRouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionRoute"]>

  export type CollectionRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    estimatedTime?: boolean
    estimatedDistance?: boolean
    schedule?: boolean
    staffId?: boolean
    averageTime?: boolean
    onTimePercentage?: boolean
    totalCollections?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | CollectionRoute$staffArgs<ExtArgs>
  }, ExtArgs["result"]["collectionRoute"]>

  export type CollectionRouteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    estimatedTime?: boolean
    estimatedDistance?: boolean
    schedule?: boolean
    staffId?: boolean
    averageTime?: boolean
    onTimePercentage?: boolean
    totalCollections?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | CollectionRoute$staffArgs<ExtArgs>
  }, ExtArgs["result"]["collectionRoute"]>

  export type CollectionRouteSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    estimatedTime?: boolean
    estimatedDistance?: boolean
    schedule?: boolean
    staffId?: boolean
    averageTime?: boolean
    onTimePercentage?: boolean
    totalCollections?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionRouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "estimatedTime" | "estimatedDistance" | "schedule" | "staffId" | "averageTime" | "onTimePercentage" | "totalCollections" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["collectionRoute"]>
  export type CollectionRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | CollectionRoute$staffArgs<ExtArgs>
    customers?: boolean | CollectionRoute$customersArgs<ExtArgs>
    eggCollections?: boolean | CollectionRoute$eggCollectionsArgs<ExtArgs>
    _count?: boolean | CollectionRouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | CollectionRoute$staffArgs<ExtArgs>
  }
  export type CollectionRouteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | CollectionRoute$staffArgs<ExtArgs>
  }

  export type $CollectionRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionRoute"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs> | null
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      eggCollections: Prisma.$EggCollectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      estimatedTime: number
      estimatedDistance: number
      schedule: $Enums.CollectionSchedule
      staffId: string | null
      averageTime: number | null
      onTimePercentage: number | null
      totalCollections: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionRoute"]>
    composites: {}
  }

  type CollectionRouteGetPayload<S extends boolean | null | undefined | CollectionRouteDefaultArgs> = $Result.GetResult<Prisma.$CollectionRoutePayload, S>

  type CollectionRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionRouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionRouteCountAggregateInputType | true
    }

  export interface CollectionRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionRoute'], meta: { name: 'CollectionRoute' } }
    /**
     * Find zero or one CollectionRoute that matches the filter.
     * @param {CollectionRouteFindUniqueArgs} args - Arguments to find a CollectionRoute
     * @example
     * // Get one CollectionRoute
     * const collectionRoute = await prisma.collectionRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionRouteFindUniqueArgs>(args: SelectSubset<T, CollectionRouteFindUniqueArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionRoute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionRouteFindUniqueOrThrowArgs} args - Arguments to find a CollectionRoute
     * @example
     * // Get one CollectionRoute
     * const collectionRoute = await prisma.collectionRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteFindFirstArgs} args - Arguments to find a CollectionRoute
     * @example
     * // Get one CollectionRoute
     * const collectionRoute = await prisma.collectionRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionRouteFindFirstArgs>(args?: SelectSubset<T, CollectionRouteFindFirstArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteFindFirstOrThrowArgs} args - Arguments to find a CollectionRoute
     * @example
     * // Get one CollectionRoute
     * const collectionRoute = await prisma.collectionRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionRoutes
     * const collectionRoutes = await prisma.collectionRoute.findMany()
     * 
     * // Get first 10 CollectionRoutes
     * const collectionRoutes = await prisma.collectionRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionRouteWithIdOnly = await prisma.collectionRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionRouteFindManyArgs>(args?: SelectSubset<T, CollectionRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionRoute.
     * @param {CollectionRouteCreateArgs} args - Arguments to create a CollectionRoute.
     * @example
     * // Create one CollectionRoute
     * const CollectionRoute = await prisma.collectionRoute.create({
     *   data: {
     *     // ... data to create a CollectionRoute
     *   }
     * })
     * 
     */
    create<T extends CollectionRouteCreateArgs>(args: SelectSubset<T, CollectionRouteCreateArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionRoutes.
     * @param {CollectionRouteCreateManyArgs} args - Arguments to create many CollectionRoutes.
     * @example
     * // Create many CollectionRoutes
     * const collectionRoute = await prisma.collectionRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionRouteCreateManyArgs>(args?: SelectSubset<T, CollectionRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionRoutes and returns the data saved in the database.
     * @param {CollectionRouteCreateManyAndReturnArgs} args - Arguments to create many CollectionRoutes.
     * @example
     * // Create many CollectionRoutes
     * const collectionRoute = await prisma.collectionRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionRoutes and only return the `id`
     * const collectionRouteWithIdOnly = await prisma.collectionRoute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionRoute.
     * @param {CollectionRouteDeleteArgs} args - Arguments to delete one CollectionRoute.
     * @example
     * // Delete one CollectionRoute
     * const CollectionRoute = await prisma.collectionRoute.delete({
     *   where: {
     *     // ... filter to delete one CollectionRoute
     *   }
     * })
     * 
     */
    delete<T extends CollectionRouteDeleteArgs>(args: SelectSubset<T, CollectionRouteDeleteArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionRoute.
     * @param {CollectionRouteUpdateArgs} args - Arguments to update one CollectionRoute.
     * @example
     * // Update one CollectionRoute
     * const collectionRoute = await prisma.collectionRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionRouteUpdateArgs>(args: SelectSubset<T, CollectionRouteUpdateArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionRoutes.
     * @param {CollectionRouteDeleteManyArgs} args - Arguments to filter CollectionRoutes to delete.
     * @example
     * // Delete a few CollectionRoutes
     * const { count } = await prisma.collectionRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionRouteDeleteManyArgs>(args?: SelectSubset<T, CollectionRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionRoutes
     * const collectionRoute = await prisma.collectionRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionRouteUpdateManyArgs>(args: SelectSubset<T, CollectionRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionRoutes and returns the data updated in the database.
     * @param {CollectionRouteUpdateManyAndReturnArgs} args - Arguments to update many CollectionRoutes.
     * @example
     * // Update many CollectionRoutes
     * const collectionRoute = await prisma.collectionRoute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionRoutes and only return the `id`
     * const collectionRouteWithIdOnly = await prisma.collectionRoute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionRouteUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionRouteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionRoute.
     * @param {CollectionRouteUpsertArgs} args - Arguments to update or create a CollectionRoute.
     * @example
     * // Update or create a CollectionRoute
     * const collectionRoute = await prisma.collectionRoute.upsert({
     *   create: {
     *     // ... data to create a CollectionRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionRoute we want to update
     *   }
     * })
     */
    upsert<T extends CollectionRouteUpsertArgs>(args: SelectSubset<T, CollectionRouteUpsertArgs<ExtArgs>>): Prisma__CollectionRouteClient<$Result.GetResult<Prisma.$CollectionRoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteCountArgs} args - Arguments to filter CollectionRoutes to count.
     * @example
     * // Count the number of CollectionRoutes
     * const count = await prisma.collectionRoute.count({
     *   where: {
     *     // ... the filter for the CollectionRoutes we want to count
     *   }
     * })
    **/
    count<T extends CollectionRouteCountArgs>(
      args?: Subset<T, CollectionRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionRouteAggregateArgs>(args: Subset<T, CollectionRouteAggregateArgs>): Prisma.PrismaPromise<GetCollectionRouteAggregateType<T>>

    /**
     * Group by CollectionRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionRouteGroupByArgs['orderBy'] }
        : { orderBy?: CollectionRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionRoute model
   */
  readonly fields: CollectionRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends CollectionRoute$staffArgs<ExtArgs> = {}>(args?: Subset<T, CollectionRoute$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customers<T extends CollectionRoute$customersArgs<ExtArgs> = {}>(args?: Subset<T, CollectionRoute$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eggCollections<T extends CollectionRoute$eggCollectionsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionRoute$eggCollectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionRoute model
   */
  interface CollectionRouteFieldRefs {
    readonly id: FieldRef<"CollectionRoute", 'String'>
    readonly name: FieldRef<"CollectionRoute", 'String'>
    readonly description: FieldRef<"CollectionRoute", 'String'>
    readonly estimatedTime: FieldRef<"CollectionRoute", 'Int'>
    readonly estimatedDistance: FieldRef<"CollectionRoute", 'Float'>
    readonly schedule: FieldRef<"CollectionRoute", 'CollectionSchedule'>
    readonly staffId: FieldRef<"CollectionRoute", 'String'>
    readonly averageTime: FieldRef<"CollectionRoute", 'Int'>
    readonly onTimePercentage: FieldRef<"CollectionRoute", 'Float'>
    readonly totalCollections: FieldRef<"CollectionRoute", 'Int'>
    readonly active: FieldRef<"CollectionRoute", 'Boolean'>
    readonly createdAt: FieldRef<"CollectionRoute", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionRoute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionRoute findUnique
   */
  export type CollectionRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * Filter, which CollectionRoute to fetch.
     */
    where: CollectionRouteWhereUniqueInput
  }

  /**
   * CollectionRoute findUniqueOrThrow
   */
  export type CollectionRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * Filter, which CollectionRoute to fetch.
     */
    where: CollectionRouteWhereUniqueInput
  }

  /**
   * CollectionRoute findFirst
   */
  export type CollectionRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * Filter, which CollectionRoute to fetch.
     */
    where?: CollectionRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionRoutes to fetch.
     */
    orderBy?: CollectionRouteOrderByWithRelationInput | CollectionRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionRoutes.
     */
    cursor?: CollectionRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionRoutes.
     */
    distinct?: CollectionRouteScalarFieldEnum | CollectionRouteScalarFieldEnum[]
  }

  /**
   * CollectionRoute findFirstOrThrow
   */
  export type CollectionRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * Filter, which CollectionRoute to fetch.
     */
    where?: CollectionRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionRoutes to fetch.
     */
    orderBy?: CollectionRouteOrderByWithRelationInput | CollectionRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionRoutes.
     */
    cursor?: CollectionRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionRoutes.
     */
    distinct?: CollectionRouteScalarFieldEnum | CollectionRouteScalarFieldEnum[]
  }

  /**
   * CollectionRoute findMany
   */
  export type CollectionRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * Filter, which CollectionRoutes to fetch.
     */
    where?: CollectionRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionRoutes to fetch.
     */
    orderBy?: CollectionRouteOrderByWithRelationInput | CollectionRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionRoutes.
     */
    cursor?: CollectionRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionRoutes.
     */
    skip?: number
    distinct?: CollectionRouteScalarFieldEnum | CollectionRouteScalarFieldEnum[]
  }

  /**
   * CollectionRoute create
   */
  export type CollectionRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionRoute.
     */
    data: XOR<CollectionRouteCreateInput, CollectionRouteUncheckedCreateInput>
  }

  /**
   * CollectionRoute createMany
   */
  export type CollectionRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionRoutes.
     */
    data: CollectionRouteCreateManyInput | CollectionRouteCreateManyInput[]
  }

  /**
   * CollectionRoute createManyAndReturn
   */
  export type CollectionRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionRoutes.
     */
    data: CollectionRouteCreateManyInput | CollectionRouteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionRoute update
   */
  export type CollectionRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionRoute.
     */
    data: XOR<CollectionRouteUpdateInput, CollectionRouteUncheckedUpdateInput>
    /**
     * Choose, which CollectionRoute to update.
     */
    where: CollectionRouteWhereUniqueInput
  }

  /**
   * CollectionRoute updateMany
   */
  export type CollectionRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionRoutes.
     */
    data: XOR<CollectionRouteUpdateManyMutationInput, CollectionRouteUncheckedUpdateManyInput>
    /**
     * Filter which CollectionRoutes to update
     */
    where?: CollectionRouteWhereInput
    /**
     * Limit how many CollectionRoutes to update.
     */
    limit?: number
  }

  /**
   * CollectionRoute updateManyAndReturn
   */
  export type CollectionRouteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * The data used to update CollectionRoutes.
     */
    data: XOR<CollectionRouteUpdateManyMutationInput, CollectionRouteUncheckedUpdateManyInput>
    /**
     * Filter which CollectionRoutes to update
     */
    where?: CollectionRouteWhereInput
    /**
     * Limit how many CollectionRoutes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionRoute upsert
   */
  export type CollectionRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionRoute to update in case it exists.
     */
    where: CollectionRouteWhereUniqueInput
    /**
     * In case the CollectionRoute found by the `where` argument doesn't exist, create a new CollectionRoute with this data.
     */
    create: XOR<CollectionRouteCreateInput, CollectionRouteUncheckedCreateInput>
    /**
     * In case the CollectionRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionRouteUpdateInput, CollectionRouteUncheckedUpdateInput>
  }

  /**
   * CollectionRoute delete
   */
  export type CollectionRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
    /**
     * Filter which CollectionRoute to delete.
     */
    where: CollectionRouteWhereUniqueInput
  }

  /**
   * CollectionRoute deleteMany
   */
  export type CollectionRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionRoutes to delete
     */
    where?: CollectionRouteWhereInput
    /**
     * Limit how many CollectionRoutes to delete.
     */
    limit?: number
  }

  /**
   * CollectionRoute.staff
   */
  export type CollectionRoute$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * CollectionRoute.customers
   */
  export type CollectionRoute$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * CollectionRoute.eggCollections
   */
  export type CollectionRoute$eggCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggCollection
     */
    select?: EggCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggCollection
     */
    omit?: EggCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggCollectionInclude<ExtArgs> | null
    where?: EggCollectionWhereInput
    orderBy?: EggCollectionOrderByWithRelationInput | EggCollectionOrderByWithRelationInput[]
    cursor?: EggCollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EggCollectionScalarFieldEnum | EggCollectionScalarFieldEnum[]
  }

  /**
   * CollectionRoute without action
   */
  export type CollectionRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionRoute
     */
    select?: CollectionRouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionRoute
     */
    omit?: CollectionRouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionRouteInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    vendorId: string | null
    orderDate: Date | null
    expectedDate: Date | null
    receivedDate: Date | null
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
    status: $Enums.PurchaseOrderStatus | null
    orderedBy: string | null
    receivedBy: string | null
    notes: string | null
    synced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    vendorId: string | null
    orderDate: Date | null
    expectedDate: Date | null
    receivedDate: Date | null
    subtotal: number | null
    tax: number | null
    shipping: number | null
    total: number | null
    status: $Enums.PurchaseOrderStatus | null
    orderedBy: string | null
    receivedBy: string | null
    notes: string | null
    synced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    vendorId: number
    orderDate: number
    expectedDate: number
    receivedDate: number
    subtotal: number
    tax: number
    shipping: number
    total: number
    status: number
    orderedBy: number
    receivedBy: number
    notes: number
    synced: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    vendorId?: true
    orderDate?: true
    expectedDate?: true
    receivedDate?: true
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
    status?: true
    orderedBy?: true
    receivedBy?: true
    notes?: true
    synced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    vendorId?: true
    orderDate?: true
    expectedDate?: true
    receivedDate?: true
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
    status?: true
    orderedBy?: true
    receivedBy?: true
    notes?: true
    synced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    vendorId?: true
    orderDate?: true
    expectedDate?: true
    receivedDate?: true
    subtotal?: true
    tax?: true
    shipping?: true
    total?: true
    status?: true
    orderedBy?: true
    receivedBy?: true
    notes?: true
    synced?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    orderNumber: string
    vendorId: string
    orderDate: Date
    expectedDate: Date | null
    receivedDate: Date | null
    subtotal: number
    tax: number
    shipping: number
    total: number
    status: $Enums.PurchaseOrderStatus
    orderedBy: string
    receivedBy: string | null
    notes: string | null
    synced: boolean
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    vendorId?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    status?: boolean
    orderedBy?: boolean
    receivedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    vendorId?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    status?: boolean
    orderedBy?: boolean
    receivedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    vendorId?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    status?: boolean
    orderedBy?: boolean
    receivedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    vendorId?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    subtotal?: boolean
    tax?: boolean
    shipping?: boolean
    total?: boolean
    status?: boolean
    orderedBy?: boolean
    receivedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "vendorId" | "orderDate" | "expectedDate" | "receivedDate" | "subtotal" | "tax" | "shipping" | "total" | "status" | "orderedBy" | "receivedBy" | "notes" | "synced" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      staff: Prisma.$StaffPayload<ExtArgs>
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      vendorId: string
      orderDate: Date
      expectedDate: Date | null
      receivedDate: Date | null
      subtotal: number
      tax: number
      shipping: number
      total: number
      status: $Enums.PurchaseOrderStatus
      orderedBy: string
      receivedBy: string | null
      notes: string | null
      synced: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly orderNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly vendorId: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly expectedDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly receivedDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly subtotal: FieldRef<"PurchaseOrder", 'Float'>
    readonly tax: FieldRef<"PurchaseOrder", 'Float'>
    readonly shipping: FieldRef<"PurchaseOrder", 'Float'>
    readonly total: FieldRef<"PurchaseOrder", 'Float'>
    readonly status: FieldRef<"PurchaseOrder", 'PurchaseOrderStatus'>
    readonly orderedBy: FieldRef<"PurchaseOrder", 'String'>
    readonly receivedBy: FieldRef<"PurchaseOrder", 'String'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly synced: FieldRef<"PurchaseOrder", 'Boolean'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    quantityOrdered: number | null
    quantityReceived: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    quantityOrdered: number | null
    quantityReceived: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantityOrdered: number | null
    quantityReceived: number | null
    unitCost: number | null
    totalCost: number | null
    productName: string | null
    productSku: string | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantityOrdered: number | null
    quantityReceived: number | null
    unitCost: number | null
    totalCost: number | null
    productName: string | null
    productSku: string | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantityOrdered: number
    quantityReceived: number
    unitCost: number
    totalCost: number
    productName: number
    productSku: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    quantityOrdered?: true
    quantityReceived?: true
    unitCost?: true
    totalCost?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    quantityOrdered?: true
    quantityReceived?: true
    unitCost?: true
    totalCost?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantityOrdered?: true
    quantityReceived?: true
    unitCost?: true
    totalCost?: true
    productName?: true
    productSku?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantityOrdered?: true
    quantityReceived?: true
    unitCost?: true
    totalCost?: true
    productName?: true
    productSku?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantityOrdered?: true
    quantityReceived?: true
    unitCost?: true
    totalCost?: true
    productName?: true
    productSku?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    purchaseOrderId: string
    productId: string
    quantityOrdered: number
    quantityReceived: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantityOrdered?: boolean
    quantityReceived?: boolean
    unitCost?: boolean
    totalCost?: boolean
    productName?: boolean
    productSku?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantityOrdered?: boolean
    quantityReceived?: boolean
    unitCost?: boolean
    totalCost?: boolean
    productName?: boolean
    productSku?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantityOrdered?: boolean
    quantityReceived?: boolean
    unitCost?: boolean
    totalCost?: boolean
    productName?: boolean
    productSku?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantityOrdered?: boolean
    quantityReceived?: boolean
    unitCost?: boolean
    totalCost?: boolean
    productName?: boolean
    productSku?: boolean
  }

  export type PurchaseOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "productId" | "quantityOrdered" | "quantityReceived" | "unitCost" | "totalCost" | "productName" | "productSku", ExtArgs["result"]["purchaseOrderItem"]>
  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      productId: string
      quantityOrdered: number
      quantityReceived: number
      unitCost: number
      totalCost: number
      productName: string
      productSku: string
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems and returns the data updated in the database.
     * @param {PurchaseOrderItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderItems.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly productId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly quantityOrdered: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly quantityReceived: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly unitCost: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly totalCost: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly productName: FieldRef<"PurchaseOrderItem", 'String'>
    readonly productSku: FieldRef<"PurchaseOrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem updateManyAndReturn
   */
  export type PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model PaymentRecord
   */

  export type AggregatePaymentRecord = {
    _count: PaymentRecordCountAggregateOutputType | null
    _avg: PaymentRecordAvgAggregateOutputType | null
    _sum: PaymentRecordSumAggregateOutputType | null
    _min: PaymentRecordMinAggregateOutputType | null
    _max: PaymentRecordMaxAggregateOutputType | null
  }

  export type PaymentRecordAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentRecordSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentRecordMinAggregateOutputType = {
    id: string | null
    type: $Enums.PaymentType | null
    amount: number | null
    customerId: string | null
    vendorId: string | null
    transactionId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    dueDate: Date | null
    referenceNumber: string | null
    checkNumber: string | null
    processedBy: string | null
    notes: string | null
    synced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRecordMaxAggregateOutputType = {
    id: string | null
    type: $Enums.PaymentType | null
    amount: number | null
    customerId: string | null
    vendorId: string | null
    transactionId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentDate: Date | null
    dueDate: Date | null
    referenceNumber: string | null
    checkNumber: string | null
    processedBy: string | null
    notes: string | null
    synced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRecordCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    customerId: number
    vendorId: number
    transactionId: number
    paymentMethod: number
    paymentDate: number
    dueDate: number
    referenceNumber: number
    checkNumber: number
    processedBy: number
    notes: number
    synced: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentRecordAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentRecordSumAggregateInputType = {
    amount?: true
  }

  export type PaymentRecordMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    paymentMethod?: true
    paymentDate?: true
    dueDate?: true
    referenceNumber?: true
    checkNumber?: true
    processedBy?: true
    notes?: true
    synced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRecordMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    paymentMethod?: true
    paymentDate?: true
    dueDate?: true
    referenceNumber?: true
    checkNumber?: true
    processedBy?: true
    notes?: true
    synced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRecordCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    customerId?: true
    vendorId?: true
    transactionId?: true
    paymentMethod?: true
    paymentDate?: true
    dueDate?: true
    referenceNumber?: true
    checkNumber?: true
    processedBy?: true
    notes?: true
    synced?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRecord to aggregate.
     */
    where?: PaymentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRecords to fetch.
     */
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentRecords
    **/
    _count?: true | PaymentRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentRecordMaxAggregateInputType
  }

  export type GetPaymentRecordAggregateType<T extends PaymentRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentRecord[P]>
      : GetScalarType<T[P], AggregatePaymentRecord[P]>
  }




  export type PaymentRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRecordWhereInput
    orderBy?: PaymentRecordOrderByWithAggregationInput | PaymentRecordOrderByWithAggregationInput[]
    by: PaymentRecordScalarFieldEnum[] | PaymentRecordScalarFieldEnum
    having?: PaymentRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentRecordCountAggregateInputType | true
    _avg?: PaymentRecordAvgAggregateInputType
    _sum?: PaymentRecordSumAggregateInputType
    _min?: PaymentRecordMinAggregateInputType
    _max?: PaymentRecordMaxAggregateInputType
  }

  export type PaymentRecordGroupByOutputType = {
    id: string
    type: $Enums.PaymentType
    amount: number
    customerId: string | null
    vendorId: string | null
    transactionId: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate: Date
    dueDate: Date | null
    referenceNumber: string | null
    checkNumber: string | null
    processedBy: string
    notes: string | null
    synced: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentRecordCountAggregateOutputType | null
    _avg: PaymentRecordAvgAggregateOutputType | null
    _sum: PaymentRecordSumAggregateOutputType | null
    _min: PaymentRecordMinAggregateOutputType | null
    _max: PaymentRecordMaxAggregateOutputType | null
  }

  type GetPaymentRecordGroupByPayload<T extends PaymentRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentRecordGroupByOutputType[P]>
        }
      >
    >


  export type PaymentRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    referenceNumber?: boolean
    checkNumber?: boolean
    processedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | PaymentRecord$customerArgs<ExtArgs>
    vendor?: boolean | PaymentRecord$vendorArgs<ExtArgs>
    transaction?: boolean | PaymentRecord$transactionArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRecord"]>

  export type PaymentRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    referenceNumber?: boolean
    checkNumber?: boolean
    processedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | PaymentRecord$customerArgs<ExtArgs>
    vendor?: boolean | PaymentRecord$vendorArgs<ExtArgs>
    transaction?: boolean | PaymentRecord$transactionArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRecord"]>

  export type PaymentRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    referenceNumber?: boolean
    checkNumber?: boolean
    processedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | PaymentRecord$customerArgs<ExtArgs>
    vendor?: boolean | PaymentRecord$vendorArgs<ExtArgs>
    transaction?: boolean | PaymentRecord$transactionArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRecord"]>

  export type PaymentRecordSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    customerId?: boolean
    vendorId?: boolean
    transactionId?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    dueDate?: boolean
    referenceNumber?: boolean
    checkNumber?: boolean
    processedBy?: boolean
    notes?: boolean
    synced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "customerId" | "vendorId" | "transactionId" | "paymentMethod" | "paymentDate" | "dueDate" | "referenceNumber" | "checkNumber" | "processedBy" | "notes" | "synced" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentRecord"]>
  export type PaymentRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PaymentRecord$customerArgs<ExtArgs>
    vendor?: boolean | PaymentRecord$vendorArgs<ExtArgs>
    transaction?: boolean | PaymentRecord$transactionArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type PaymentRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PaymentRecord$customerArgs<ExtArgs>
    vendor?: boolean | PaymentRecord$vendorArgs<ExtArgs>
    transaction?: boolean | PaymentRecord$transactionArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type PaymentRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | PaymentRecord$customerArgs<ExtArgs>
    vendor?: boolean | PaymentRecord$vendorArgs<ExtArgs>
    transaction?: boolean | PaymentRecord$transactionArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $PaymentRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentRecord"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.PaymentType
      amount: number
      customerId: string | null
      vendorId: string | null
      transactionId: string | null
      paymentMethod: $Enums.PaymentMethod
      paymentDate: Date
      dueDate: Date | null
      referenceNumber: string | null
      checkNumber: string | null
      processedBy: string
      notes: string | null
      synced: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentRecord"]>
    composites: {}
  }

  type PaymentRecordGetPayload<S extends boolean | null | undefined | PaymentRecordDefaultArgs> = $Result.GetResult<Prisma.$PaymentRecordPayload, S>

  type PaymentRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentRecordCountAggregateInputType | true
    }

  export interface PaymentRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentRecord'], meta: { name: 'PaymentRecord' } }
    /**
     * Find zero or one PaymentRecord that matches the filter.
     * @param {PaymentRecordFindUniqueArgs} args - Arguments to find a PaymentRecord
     * @example
     * // Get one PaymentRecord
     * const paymentRecord = await prisma.paymentRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentRecordFindUniqueArgs>(args: SelectSubset<T, PaymentRecordFindUniqueArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentRecordFindUniqueOrThrowArgs} args - Arguments to find a PaymentRecord
     * @example
     * // Get one PaymentRecord
     * const paymentRecord = await prisma.paymentRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordFindFirstArgs} args - Arguments to find a PaymentRecord
     * @example
     * // Get one PaymentRecord
     * const paymentRecord = await prisma.paymentRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentRecordFindFirstArgs>(args?: SelectSubset<T, PaymentRecordFindFirstArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordFindFirstOrThrowArgs} args - Arguments to find a PaymentRecord
     * @example
     * // Get one PaymentRecord
     * const paymentRecord = await prisma.paymentRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentRecords
     * const paymentRecords = await prisma.paymentRecord.findMany()
     * 
     * // Get first 10 PaymentRecords
     * const paymentRecords = await prisma.paymentRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentRecordWithIdOnly = await prisma.paymentRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentRecordFindManyArgs>(args?: SelectSubset<T, PaymentRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentRecord.
     * @param {PaymentRecordCreateArgs} args - Arguments to create a PaymentRecord.
     * @example
     * // Create one PaymentRecord
     * const PaymentRecord = await prisma.paymentRecord.create({
     *   data: {
     *     // ... data to create a PaymentRecord
     *   }
     * })
     * 
     */
    create<T extends PaymentRecordCreateArgs>(args: SelectSubset<T, PaymentRecordCreateArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentRecords.
     * @param {PaymentRecordCreateManyArgs} args - Arguments to create many PaymentRecords.
     * @example
     * // Create many PaymentRecords
     * const paymentRecord = await prisma.paymentRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentRecordCreateManyArgs>(args?: SelectSubset<T, PaymentRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentRecords and returns the data saved in the database.
     * @param {PaymentRecordCreateManyAndReturnArgs} args - Arguments to create many PaymentRecords.
     * @example
     * // Create many PaymentRecords
     * const paymentRecord = await prisma.paymentRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentRecords and only return the `id`
     * const paymentRecordWithIdOnly = await prisma.paymentRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentRecord.
     * @param {PaymentRecordDeleteArgs} args - Arguments to delete one PaymentRecord.
     * @example
     * // Delete one PaymentRecord
     * const PaymentRecord = await prisma.paymentRecord.delete({
     *   where: {
     *     // ... filter to delete one PaymentRecord
     *   }
     * })
     * 
     */
    delete<T extends PaymentRecordDeleteArgs>(args: SelectSubset<T, PaymentRecordDeleteArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentRecord.
     * @param {PaymentRecordUpdateArgs} args - Arguments to update one PaymentRecord.
     * @example
     * // Update one PaymentRecord
     * const paymentRecord = await prisma.paymentRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentRecordUpdateArgs>(args: SelectSubset<T, PaymentRecordUpdateArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentRecords.
     * @param {PaymentRecordDeleteManyArgs} args - Arguments to filter PaymentRecords to delete.
     * @example
     * // Delete a few PaymentRecords
     * const { count } = await prisma.paymentRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentRecordDeleteManyArgs>(args?: SelectSubset<T, PaymentRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentRecords
     * const paymentRecord = await prisma.paymentRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentRecordUpdateManyArgs>(args: SelectSubset<T, PaymentRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRecords and returns the data updated in the database.
     * @param {PaymentRecordUpdateManyAndReturnArgs} args - Arguments to update many PaymentRecords.
     * @example
     * // Update many PaymentRecords
     * const paymentRecord = await prisma.paymentRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentRecords and only return the `id`
     * const paymentRecordWithIdOnly = await prisma.paymentRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentRecord.
     * @param {PaymentRecordUpsertArgs} args - Arguments to update or create a PaymentRecord.
     * @example
     * // Update or create a PaymentRecord
     * const paymentRecord = await prisma.paymentRecord.upsert({
     *   create: {
     *     // ... data to create a PaymentRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentRecord we want to update
     *   }
     * })
     */
    upsert<T extends PaymentRecordUpsertArgs>(args: SelectSubset<T, PaymentRecordUpsertArgs<ExtArgs>>): Prisma__PaymentRecordClient<$Result.GetResult<Prisma.$PaymentRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordCountArgs} args - Arguments to filter PaymentRecords to count.
     * @example
     * // Count the number of PaymentRecords
     * const count = await prisma.paymentRecord.count({
     *   where: {
     *     // ... the filter for the PaymentRecords we want to count
     *   }
     * })
    **/
    count<T extends PaymentRecordCountArgs>(
      args?: Subset<T, PaymentRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentRecordAggregateArgs>(args: Subset<T, PaymentRecordAggregateArgs>): Prisma.PrismaPromise<GetPaymentRecordAggregateType<T>>

    /**
     * Group by PaymentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentRecordGroupByArgs['orderBy'] }
        : { orderBy?: PaymentRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentRecord model
   */
  readonly fields: PaymentRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends PaymentRecord$customerArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRecord$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends PaymentRecord$vendorArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRecord$vendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends PaymentRecord$transactionArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRecord$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentRecord model
   */
  interface PaymentRecordFieldRefs {
    readonly id: FieldRef<"PaymentRecord", 'String'>
    readonly type: FieldRef<"PaymentRecord", 'PaymentType'>
    readonly amount: FieldRef<"PaymentRecord", 'Float'>
    readonly customerId: FieldRef<"PaymentRecord", 'String'>
    readonly vendorId: FieldRef<"PaymentRecord", 'String'>
    readonly transactionId: FieldRef<"PaymentRecord", 'String'>
    readonly paymentMethod: FieldRef<"PaymentRecord", 'PaymentMethod'>
    readonly paymentDate: FieldRef<"PaymentRecord", 'DateTime'>
    readonly dueDate: FieldRef<"PaymentRecord", 'DateTime'>
    readonly referenceNumber: FieldRef<"PaymentRecord", 'String'>
    readonly checkNumber: FieldRef<"PaymentRecord", 'String'>
    readonly processedBy: FieldRef<"PaymentRecord", 'String'>
    readonly notes: FieldRef<"PaymentRecord", 'String'>
    readonly synced: FieldRef<"PaymentRecord", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentRecord findUnique
   */
  export type PaymentRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRecord to fetch.
     */
    where: PaymentRecordWhereUniqueInput
  }

  /**
   * PaymentRecord findUniqueOrThrow
   */
  export type PaymentRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRecord to fetch.
     */
    where: PaymentRecordWhereUniqueInput
  }

  /**
   * PaymentRecord findFirst
   */
  export type PaymentRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRecord to fetch.
     */
    where?: PaymentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRecords to fetch.
     */
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRecords.
     */
    cursor?: PaymentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRecords.
     */
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * PaymentRecord findFirstOrThrow
   */
  export type PaymentRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRecord to fetch.
     */
    where?: PaymentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRecords to fetch.
     */
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRecords.
     */
    cursor?: PaymentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRecords.
     */
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * PaymentRecord findMany
   */
  export type PaymentRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRecords to fetch.
     */
    where?: PaymentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRecords to fetch.
     */
    orderBy?: PaymentRecordOrderByWithRelationInput | PaymentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentRecords.
     */
    cursor?: PaymentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRecords.
     */
    skip?: number
    distinct?: PaymentRecordScalarFieldEnum | PaymentRecordScalarFieldEnum[]
  }

  /**
   * PaymentRecord create
   */
  export type PaymentRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentRecord.
     */
    data: XOR<PaymentRecordCreateInput, PaymentRecordUncheckedCreateInput>
  }

  /**
   * PaymentRecord createMany
   */
  export type PaymentRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentRecords.
     */
    data: PaymentRecordCreateManyInput | PaymentRecordCreateManyInput[]
  }

  /**
   * PaymentRecord createManyAndReturn
   */
  export type PaymentRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentRecords.
     */
    data: PaymentRecordCreateManyInput | PaymentRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRecord update
   */
  export type PaymentRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentRecord.
     */
    data: XOR<PaymentRecordUpdateInput, PaymentRecordUncheckedUpdateInput>
    /**
     * Choose, which PaymentRecord to update.
     */
    where: PaymentRecordWhereUniqueInput
  }

  /**
   * PaymentRecord updateMany
   */
  export type PaymentRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentRecords.
     */
    data: XOR<PaymentRecordUpdateManyMutationInput, PaymentRecordUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRecords to update
     */
    where?: PaymentRecordWhereInput
    /**
     * Limit how many PaymentRecords to update.
     */
    limit?: number
  }

  /**
   * PaymentRecord updateManyAndReturn
   */
  export type PaymentRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * The data used to update PaymentRecords.
     */
    data: XOR<PaymentRecordUpdateManyMutationInput, PaymentRecordUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRecords to update
     */
    where?: PaymentRecordWhereInput
    /**
     * Limit how many PaymentRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRecord upsert
   */
  export type PaymentRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentRecord to update in case it exists.
     */
    where: PaymentRecordWhereUniqueInput
    /**
     * In case the PaymentRecord found by the `where` argument doesn't exist, create a new PaymentRecord with this data.
     */
    create: XOR<PaymentRecordCreateInput, PaymentRecordUncheckedCreateInput>
    /**
     * In case the PaymentRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentRecordUpdateInput, PaymentRecordUncheckedUpdateInput>
  }

  /**
   * PaymentRecord delete
   */
  export type PaymentRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
    /**
     * Filter which PaymentRecord to delete.
     */
    where: PaymentRecordWhereUniqueInput
  }

  /**
   * PaymentRecord deleteMany
   */
  export type PaymentRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRecords to delete
     */
    where?: PaymentRecordWhereInput
    /**
     * Limit how many PaymentRecords to delete.
     */
    limit?: number
  }

  /**
   * PaymentRecord.customer
   */
  export type PaymentRecord$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * PaymentRecord.vendor
   */
  export type PaymentRecord$vendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * PaymentRecord.transaction
   */
  export type PaymentRecord$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * PaymentRecord without action
   */
  export type PaymentRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRecord
     */
    select?: PaymentRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentRecord
     */
    omit?: PaymentRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRecordInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: $Enums.SettingType | null
    description: string | null
    category: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: $Enums.SettingType | null
    description: string | null
    category: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    description: number
    category: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    description?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    description?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    description?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    type: $Enums.SettingType
    description: string | null
    category: string
    updatedAt: Date
    updatedBy: string | null
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    description?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    description?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    description?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    description?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "type" | "description" | "category" | "updatedAt" | "updatedBy", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      type: $Enums.SettingType
      description: string | null
      category: string
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly type: FieldRef<"SystemSetting", 'SettingType'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedBy: FieldRef<"SystemSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    action: $Enums.AuditAction | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    action: $Enums.AuditAction | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    action: number
    oldValues: number
    newValues: number
    userId: number
    userAgent: number
    ipAddress: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    oldValues?: true
    newValues?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldValues: JsonValue | null
    newValues: JsonValue | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldValues?: boolean
    newValues?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "action" | "oldValues" | "newValues" | "userId" | "userAgent" | "ipAddress" | "timestamp", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      action: $Enums.AuditAction
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      userId: string | null
      userAgent: string | null
      ipAddress: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogAvgAggregateOutputType = {
    attempts: number | null
  }

  export type SyncLogSumAggregateOutputType = {
    attempts: number | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operation: $Enums.SyncOperation | null
    syncedAt: Date | null
    success: boolean | null
    error: string | null
    attempts: number | null
    conflictResolution: string | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operation: $Enums.SyncOperation | null
    syncedAt: Date | null
    success: boolean | null
    error: string | null
    attempts: number | null
    conflictResolution: string | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    operation: number
    syncedAt: number
    success: number
    error: number
    attempts: number
    conflictResolution: number
    _all: number
  }


  export type SyncLogAvgAggregateInputType = {
    attempts?: true
  }

  export type SyncLogSumAggregateInputType = {
    attempts?: true
  }

  export type SyncLogMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    syncedAt?: true
    success?: true
    error?: true
    attempts?: true
    conflictResolution?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    syncedAt?: true
    success?: true
    error?: true
    attempts?: true
    conflictResolution?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    syncedAt?: true
    success?: true
    error?: true
    attempts?: true
    conflictResolution?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _avg?: SyncLogAvgAggregateInputType
    _sum?: SyncLogSumAggregateInputType
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    operation: $Enums.SyncOperation
    syncedAt: Date
    success: boolean
    error: string | null
    attempts: number
    conflictResolution: string | null
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    syncedAt?: boolean
    success?: boolean
    error?: boolean
    attempts?: boolean
    conflictResolution?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    syncedAt?: boolean
    success?: boolean
    error?: boolean
    attempts?: boolean
    conflictResolution?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    syncedAt?: boolean
    success?: boolean
    error?: boolean
    attempts?: boolean
    conflictResolution?: boolean
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    syncedAt?: boolean
    success?: boolean
    error?: boolean
    attempts?: boolean
    conflictResolution?: boolean
  }

  export type SyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "operation" | "syncedAt" | "success" | "error" | "attempts" | "conflictResolution", ExtArgs["result"]["syncLog"]>

  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      operation: $Enums.SyncOperation
      syncedAt: Date
      success: boolean
      error: string | null
      attempts: number
      conflictResolution: string | null
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs and returns the data updated in the database.
     * @param {SyncLogUpdateManyAndReturnArgs} args - Arguments to update many SyncLogs.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly tableName: FieldRef<"SyncLog", 'String'>
    readonly recordId: FieldRef<"SyncLog", 'String'>
    readonly operation: FieldRef<"SyncLog", 'SyncOperation'>
    readonly syncedAt: FieldRef<"SyncLog", 'DateTime'>
    readonly success: FieldRef<"SyncLog", 'Boolean'>
    readonly error: FieldRef<"SyncLog", 'String'>
    readonly attempts: FieldRef<"SyncLog", 'Int'>
    readonly conflictResolution: FieldRef<"SyncLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
  }

  /**
   * SyncLog updateManyAndReturn
   */
  export type SyncLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to delete.
     */
    limit?: number
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    category: $Enums.NotificationCategory | null
    priority: $Enums.NotificationPriority | null
    title: string | null
    message: string | null
    globalNotification: boolean | null
    read: boolean | null
    readAt: Date | null
    readBy: string | null
    expiresAt: Date | null
    actionRequired: boolean | null
    actionUrl: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    category: $Enums.NotificationCategory | null
    priority: $Enums.NotificationPriority | null
    title: string | null
    message: string | null
    globalNotification: boolean | null
    read: boolean | null
    readAt: Date | null
    readBy: string | null
    expiresAt: Date | null
    actionRequired: boolean | null
    actionUrl: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    category: number
    priority: number
    title: number
    message: number
    recipientIds: number
    globalNotification: number
    read: number
    readAt: number
    readBy: number
    expiresAt: number
    actionRequired: number
    actionUrl: number
    actionData: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    priority?: true
    title?: true
    message?: true
    globalNotification?: true
    read?: true
    readAt?: true
    readBy?: true
    expiresAt?: true
    actionRequired?: true
    actionUrl?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    priority?: true
    title?: true
    message?: true
    globalNotification?: true
    read?: true
    readAt?: true
    readBy?: true
    expiresAt?: true
    actionRequired?: true
    actionUrl?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    priority?: true
    title?: true
    message?: true
    recipientIds?: true
    globalNotification?: true
    read?: true
    readAt?: true
    readBy?: true
    expiresAt?: true
    actionRequired?: true
    actionUrl?: true
    actionData?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    priority: $Enums.NotificationPriority
    title: string
    message: string
    recipientIds: JsonValue | null
    globalNotification: boolean
    read: boolean
    readAt: Date | null
    readBy: string | null
    expiresAt: Date | null
    actionRequired: boolean
    actionUrl: string | null
    actionData: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    recipientIds?: boolean
    globalNotification?: boolean
    read?: boolean
    readAt?: boolean
    readBy?: boolean
    expiresAt?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    actionData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    recipientIds?: boolean
    globalNotification?: boolean
    read?: boolean
    readAt?: boolean
    readBy?: boolean
    expiresAt?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    actionData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    recipientIds?: boolean
    globalNotification?: boolean
    read?: boolean
    readAt?: boolean
    readBy?: boolean
    expiresAt?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    actionData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    priority?: boolean
    title?: boolean
    message?: boolean
    recipientIds?: boolean
    globalNotification?: boolean
    read?: boolean
    readAt?: boolean
    readBy?: boolean
    expiresAt?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    actionData?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "priority" | "title" | "message" | "recipientIds" | "globalNotification" | "read" | "readAt" | "readBy" | "expiresAt" | "actionRequired" | "actionUrl" | "actionData" | "createdAt", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      category: $Enums.NotificationCategory
      priority: $Enums.NotificationPriority
      title: string
      message: string
      recipientIds: Prisma.JsonValue | null
      globalNotification: boolean
      read: boolean
      readAt: Date | null
      readBy: string | null
      expiresAt: Date | null
      actionRequired: boolean
      actionUrl: string | null
      actionData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly category: FieldRef<"Notification", 'NotificationCategory'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly recipientIds: FieldRef<"Notification", 'Json'>
    readonly globalNotification: FieldRef<"Notification", 'Boolean'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly readBy: FieldRef<"Notification", 'String'>
    readonly expiresAt: FieldRef<"Notification", 'DateTime'>
    readonly actionRequired: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly actionData: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    website: 'website',
    taxRate: 'taxRate',
    currency: 'currency',
    timezone: 'timezone',
    receiptHeader: 'receiptHeader',
    receiptFooter: 'receiptFooter',
    printLogo: 'printLogo',
    logoData: 'logoData',
    creditTermsDefault: 'creditTermsDefault',
    maxCreditLimit: 'maxCreditLimit',
    interestRate: 'interestRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    position: 'position',
    department: 'department',
    hireDate: 'hireDate',
    salary: 'salary',
    active: 'active',
    username: 'username',
    password: 'password',
    lastLogin: 'lastLogin',
    permissions: 'permissions',
    totalCollections: 'totalCollections',
    averageQuality: 'averageQuality',
    onTimeRate: 'onTimeRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    type: 'type',
    businessName: 'businessName',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    address: 'address',
    creditLimit: 'creditLimit',
    creditBalance: 'creditBalance',
    paymentTerms: 'paymentTerms',
    creditStatus: 'creditStatus',
    farmSize: 'farmSize',
    animalTypes: 'animalTypes',
    henEggsDailyProduction: 'henEggsDailyProduction',
    duckEggsDailyProduction: 'duckEggsDailyProduction',
    collectionSchedule: 'collectionSchedule',
    isRetail: 'isRetail',
    loyaltyPoints: 'loyaltyPoints',
    totalPurchases: 'totalPurchases',
    totalEggSales: 'totalEggSales',
    lastPurchase: 'lastPurchase',
    lastEggCollection: 'lastEggCollection',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    street: 'street',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    creditLimit: 'creditLimit',
    creditBalance: 'creditBalance',
    paymentTerms: 'paymentTerms',
    earlyPaymentDiscount: 'earlyPaymentDiscount',
    productTypes: 'productTypes',
    totalPurchases: 'totalPurchases',
    onTimePaymentRate: 'onTimePaymentRate',
    lastOrder: 'lastOrder',
    lastPayment: 'lastPayment',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    type: 'type',
    category: 'category',
    costPrice: 'costPrice',
    sellingPrice: 'sellingPrice',
    wholesalePrice: 'wholesalePrice',
    stock: 'stock',
    unit: 'unit',
    minimumStock: 'minimumStock',
    expiryDate: 'expiryDate',
    batchNumber: 'batchNumber',
    manufacturer: 'manufacturer',
    requiresPrescription: 'requiresPrescription',
    activeIngredient: 'activeIngredient',
    dosage: 'dosage',
    animalType: 'animalType',
    nutritionInfo: 'nutritionInfo',
    feedType: 'feedType',
    primaryVendorId: 'primaryVendorId',
    alternateVendors: 'alternateVendors',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    receiptNumber: 'receiptNumber',
    type: 'type',
    customerId: 'customerId',
    vendorId: 'vendorId',
    subtotal: 'subtotal',
    tax: 'tax',
    discount: 'discount',
    total: 'total',
    paymentMethod: 'paymentMethod',
    paidAmount: 'paidAmount',
    balanceAmount: 'balanceAmount',
    status: 'status',
    timestamp: 'timestamp',
    dueDate: 'dueDate',
    staffId: 'staffId',
    notes: 'notes',
    synced: 'synced',
    cloudId: 'cloudId',
    syncError: 'syncError',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionItemScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total',
    productName: 'productName',
    productSku: 'productSku',
    unit: 'unit',
    batchNumber: 'batchNumber',
    expiryDate: 'expiryDate',
    grade: 'grade'
  };

  export type TransactionItemScalarFieldEnum = (typeof TransactionItemScalarFieldEnum)[keyof typeof TransactionItemScalarFieldEnum]


  export const EggCollectionScalarFieldEnum: {
    id: 'id',
    farmerId: 'farmerId',
    routeId: 'routeId',
    staffId: 'staffId',
    collectionDate: 'collectionDate',
    henEggsSmall: 'henEggsSmall',
    henEggsMedium: 'henEggsMedium',
    henEggsLarge: 'henEggsLarge',
    henEggsExtraLarge: 'henEggsExtraLarge',
    henEggsDamaged: 'henEggsDamaged',
    totalHenEggs: 'totalHenEggs',
    duckEggsSmall: 'duckEggsSmall',
    duckEggsMedium: 'duckEggsMedium',
    duckEggsLarge: 'duckEggsLarge',
    duckEggsDamaged: 'duckEggsDamaged',
    totalDuckEggs: 'totalDuckEggs',
    henEggPrice: 'henEggPrice',
    duckEggPrice: 'duckEggPrice',
    totalValue: 'totalValue',
    qualityScore: 'qualityScore',
    qualityNotes: 'qualityNotes',
    paid: 'paid',
    paymentDate: 'paymentDate',
    synced: 'synced',
    cloudId: 'cloudId',
    syncError: 'syncError',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EggCollectionScalarFieldEnum = (typeof EggCollectionScalarFieldEnum)[keyof typeof EggCollectionScalarFieldEnum]


  export const CollectionRouteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    estimatedTime: 'estimatedTime',
    estimatedDistance: 'estimatedDistance',
    schedule: 'schedule',
    staffId: 'staffId',
    averageTime: 'averageTime',
    onTimePercentage: 'onTimePercentage',
    totalCollections: 'totalCollections',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionRouteScalarFieldEnum = (typeof CollectionRouteScalarFieldEnum)[keyof typeof CollectionRouteScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    vendorId: 'vendorId',
    orderDate: 'orderDate',
    expectedDate: 'expectedDate',
    receivedDate: 'receivedDate',
    subtotal: 'subtotal',
    tax: 'tax',
    shipping: 'shipping',
    total: 'total',
    status: 'status',
    orderedBy: 'orderedBy',
    receivedBy: 'receivedBy',
    notes: 'notes',
    synced: 'synced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    quantityOrdered: 'quantityOrdered',
    quantityReceived: 'quantityReceived',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    productName: 'productName',
    productSku: 'productSku'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const PaymentRecordScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    customerId: 'customerId',
    vendorId: 'vendorId',
    transactionId: 'transactionId',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    dueDate: 'dueDate',
    referenceNumber: 'referenceNumber',
    checkNumber: 'checkNumber',
    processedBy: 'processedBy',
    notes: 'notes',
    synced: 'synced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentRecordScalarFieldEnum = (typeof PaymentRecordScalarFieldEnum)[keyof typeof PaymentRecordScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    description: 'description',
    category: 'category',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    action: 'action',
    oldValues: 'oldValues',
    newValues: 'newValues',
    userId: 'userId',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    operation: 'operation',
    syncedAt: 'syncedAt',
    success: 'success',
    error: 'error',
    attempts: 'attempts',
    conflictResolution: 'conflictResolution'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    priority: 'priority',
    title: 'title',
    message: 'message',
    recipientIds: 'recipientIds',
    globalNotification: 'globalNotification',
    read: 'read',
    readAt: 'readAt',
    readBy: 'readBy',
    expiresAt: 'expiresAt',
    actionRequired: 'actionRequired',
    actionUrl: 'actionUrl',
    actionData: 'actionData',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'StaffPosition'
   */
  export type EnumStaffPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffPosition'>
    


  /**
   * Reference to a field of type 'StaffDepartment'
   */
  export type EnumStaffDepartmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffDepartment'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'CreditStatus'
   */
  export type EnumCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditStatus'>
    


  /**
   * Reference to a field of type 'CollectionSchedule'
   */
  export type EnumCollectionScheduleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionSchedule'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'PurchaseOrderStatus'
   */
  export type EnumPurchaseOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderStatus'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'SettingType'
   */
  export type EnumSettingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SettingType'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'SyncOperation'
   */
  export type EnumSyncOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncOperation'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationCategory'
   */
  export type EnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    
  /**
   * Deep Input Types
   */


  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    address?: StringFilter<"Store"> | string
    phone?: StringFilter<"Store"> | string
    email?: StringNullableFilter<"Store"> | string | null
    website?: StringNullableFilter<"Store"> | string | null
    taxRate?: FloatFilter<"Store"> | number
    currency?: StringFilter<"Store"> | string
    timezone?: StringFilter<"Store"> | string
    receiptHeader?: StringNullableFilter<"Store"> | string | null
    receiptFooter?: StringNullableFilter<"Store"> | string | null
    printLogo?: BoolFilter<"Store"> | boolean
    logoData?: StringNullableFilter<"Store"> | string | null
    creditTermsDefault?: IntFilter<"Store"> | number
    maxCreditLimit?: FloatFilter<"Store"> | number
    interestRate?: FloatFilter<"Store"> | number
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrderInput | SortOrder
    receiptFooter?: SortOrderInput | SortOrder
    printLogo?: SortOrder
    logoData?: SortOrderInput | SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    address?: StringFilter<"Store"> | string
    phone?: StringFilter<"Store"> | string
    email?: StringNullableFilter<"Store"> | string | null
    website?: StringNullableFilter<"Store"> | string | null
    taxRate?: FloatFilter<"Store"> | number
    currency?: StringFilter<"Store"> | string
    timezone?: StringFilter<"Store"> | string
    receiptHeader?: StringNullableFilter<"Store"> | string | null
    receiptFooter?: StringNullableFilter<"Store"> | string | null
    printLogo?: BoolFilter<"Store"> | boolean
    logoData?: StringNullableFilter<"Store"> | string | null
    creditTermsDefault?: IntFilter<"Store"> | number
    maxCreditLimit?: FloatFilter<"Store"> | number
    interestRate?: FloatFilter<"Store"> | number
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
  }, "id">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrderInput | SortOrder
    receiptFooter?: SortOrderInput | SortOrder
    printLogo?: SortOrder
    logoData?: SortOrderInput | SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    address?: StringWithAggregatesFilter<"Store"> | string
    phone?: StringWithAggregatesFilter<"Store"> | string
    email?: StringNullableWithAggregatesFilter<"Store"> | string | null
    website?: StringNullableWithAggregatesFilter<"Store"> | string | null
    taxRate?: FloatWithAggregatesFilter<"Store"> | number
    currency?: StringWithAggregatesFilter<"Store"> | string
    timezone?: StringWithAggregatesFilter<"Store"> | string
    receiptHeader?: StringNullableWithAggregatesFilter<"Store"> | string | null
    receiptFooter?: StringNullableWithAggregatesFilter<"Store"> | string | null
    printLogo?: BoolWithAggregatesFilter<"Store"> | boolean
    logoData?: StringNullableWithAggregatesFilter<"Store"> | string | null
    creditTermsDefault?: IntWithAggregatesFilter<"Store"> | number
    maxCreditLimit?: FloatWithAggregatesFilter<"Store"> | number
    interestRate?: FloatWithAggregatesFilter<"Store"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    employeeId?: StringFilter<"Staff"> | string
    firstName?: StringFilter<"Staff"> | string
    lastName?: StringFilter<"Staff"> | string
    email?: StringNullableFilter<"Staff"> | string | null
    phone?: StringNullableFilter<"Staff"> | string | null
    position?: EnumStaffPositionFilter<"Staff"> | $Enums.StaffPosition
    department?: EnumStaffDepartmentFilter<"Staff"> | $Enums.StaffDepartment
    hireDate?: DateTimeFilter<"Staff"> | Date | string
    salary?: IntFilter<"Staff"> | number
    active?: BoolFilter<"Staff"> | boolean
    username?: StringFilter<"Staff"> | string
    password?: StringNullableFilter<"Staff"> | string | null
    lastLogin?: DateTimeNullableFilter<"Staff"> | Date | string | null
    permissions?: JsonFilter<"Staff">
    totalCollections?: IntNullableFilter<"Staff"> | number | null
    averageQuality?: FloatNullableFilter<"Staff"> | number | null
    onTimeRate?: FloatNullableFilter<"Staff"> | number | null
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    transactions?: TransactionListRelationFilter
    eggCollections?: EggCollectionListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
    collectionRoutes?: CollectionRouteListRelationFilter
    PurchaseOrder?: PurchaseOrderListRelationFilter
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    active?: SortOrder
    username?: SortOrder
    password?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    permissions?: SortOrder
    totalCollections?: SortOrderInput | SortOrder
    averageQuality?: SortOrderInput | SortOrder
    onTimeRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    eggCollections?: EggCollectionOrderByRelationAggregateInput
    paymentRecords?: PaymentRecordOrderByRelationAggregateInput
    collectionRoutes?: CollectionRouteOrderByRelationAggregateInput
    PurchaseOrder?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    email?: string
    username?: string
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    firstName?: StringFilter<"Staff"> | string
    lastName?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    position?: EnumStaffPositionFilter<"Staff"> | $Enums.StaffPosition
    department?: EnumStaffDepartmentFilter<"Staff"> | $Enums.StaffDepartment
    hireDate?: DateTimeFilter<"Staff"> | Date | string
    salary?: IntFilter<"Staff"> | number
    active?: BoolFilter<"Staff"> | boolean
    password?: StringNullableFilter<"Staff"> | string | null
    lastLogin?: DateTimeNullableFilter<"Staff"> | Date | string | null
    permissions?: JsonFilter<"Staff">
    totalCollections?: IntNullableFilter<"Staff"> | number | null
    averageQuality?: FloatNullableFilter<"Staff"> | number | null
    onTimeRate?: FloatNullableFilter<"Staff"> | number | null
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    transactions?: TransactionListRelationFilter
    eggCollections?: EggCollectionListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
    collectionRoutes?: CollectionRouteListRelationFilter
    PurchaseOrder?: PurchaseOrderListRelationFilter
  }, "id" | "employeeId" | "email" | "username">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    active?: SortOrder
    username?: SortOrder
    password?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    permissions?: SortOrder
    totalCollections?: SortOrderInput | SortOrder
    averageQuality?: SortOrderInput | SortOrder
    onTimeRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _avg?: StaffAvgOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
    _sum?: StaffSumOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    employeeId?: StringWithAggregatesFilter<"Staff"> | string
    firstName?: StringWithAggregatesFilter<"Staff"> | string
    lastName?: StringWithAggregatesFilter<"Staff"> | string
    email?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    position?: EnumStaffPositionWithAggregatesFilter<"Staff"> | $Enums.StaffPosition
    department?: EnumStaffDepartmentWithAggregatesFilter<"Staff"> | $Enums.StaffDepartment
    hireDate?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    salary?: IntWithAggregatesFilter<"Staff"> | number
    active?: BoolWithAggregatesFilter<"Staff"> | boolean
    username?: StringWithAggregatesFilter<"Staff"> | string
    password?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"Staff"> | Date | string | null
    permissions?: JsonWithAggregatesFilter<"Staff">
    totalCollections?: IntNullableWithAggregatesFilter<"Staff"> | number | null
    averageQuality?: FloatNullableWithAggregatesFilter<"Staff"> | number | null
    onTimeRate?: FloatNullableWithAggregatesFilter<"Staff"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    businessName?: StringNullableFilter<"Customer"> | string | null
    contactPerson?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: IntFilter<"Customer"> | number
    creditBalance?: IntFilter<"Customer"> | number
    paymentTerms?: IntFilter<"Customer"> | number
    creditStatus?: EnumCreditStatusFilter<"Customer"> | $Enums.CreditStatus
    farmSize?: FloatNullableFilter<"Customer"> | number | null
    animalTypes?: JsonNullableFilter<"Customer">
    henEggsDailyProduction?: IntFilter<"Customer"> | number
    duckEggsDailyProduction?: IntFilter<"Customer"> | number
    collectionSchedule?: EnumCollectionScheduleFilter<"Customer"> | $Enums.CollectionSchedule
    isRetail?: BoolFilter<"Customer"> | boolean
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalPurchases?: IntFilter<"Customer"> | number
    totalEggSales?: IntFilter<"Customer"> | number
    lastPurchase?: DateTimeNullableFilter<"Customer"> | Date | string | null
    lastEggCollection?: DateTimeNullableFilter<"Customer"> | Date | string | null
    active?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
    eggCollections?: EggCollectionListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
    routes?: CollectionRouteListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    businessName?: SortOrderInput | SortOrder
    contactPerson?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    creditStatus?: SortOrder
    farmSize?: SortOrderInput | SortOrder
    animalTypes?: SortOrderInput | SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    collectionSchedule?: SortOrder
    isRetail?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
    lastPurchase?: SortOrderInput | SortOrder
    lastEggCollection?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    eggCollections?: EggCollectionOrderByRelationAggregateInput
    paymentRecords?: PaymentRecordOrderByRelationAggregateInput
    routes?: CollectionRouteOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    businessName?: StringNullableFilter<"Customer"> | string | null
    contactPerson?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: IntFilter<"Customer"> | number
    creditBalance?: IntFilter<"Customer"> | number
    paymentTerms?: IntFilter<"Customer"> | number
    creditStatus?: EnumCreditStatusFilter<"Customer"> | $Enums.CreditStatus
    farmSize?: FloatNullableFilter<"Customer"> | number | null
    animalTypes?: JsonNullableFilter<"Customer">
    henEggsDailyProduction?: IntFilter<"Customer"> | number
    duckEggsDailyProduction?: IntFilter<"Customer"> | number
    collectionSchedule?: EnumCollectionScheduleFilter<"Customer"> | $Enums.CollectionSchedule
    isRetail?: BoolFilter<"Customer"> | boolean
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalPurchases?: IntFilter<"Customer"> | number
    totalEggSales?: IntFilter<"Customer"> | number
    lastPurchase?: DateTimeNullableFilter<"Customer"> | Date | string | null
    lastEggCollection?: DateTimeNullableFilter<"Customer"> | Date | string | null
    active?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
    eggCollections?: EggCollectionListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
    routes?: CollectionRouteListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    businessName?: SortOrderInput | SortOrder
    contactPerson?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    creditStatus?: SortOrder
    farmSize?: SortOrderInput | SortOrder
    animalTypes?: SortOrderInput | SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    collectionSchedule?: SortOrder
    isRetail?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
    lastPurchase?: SortOrderInput | SortOrder
    lastEggCollection?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    type?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    businessName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    contactPerson?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    creditLimit?: IntWithAggregatesFilter<"Customer"> | number
    creditBalance?: IntWithAggregatesFilter<"Customer"> | number
    paymentTerms?: IntWithAggregatesFilter<"Customer"> | number
    creditStatus?: EnumCreditStatusWithAggregatesFilter<"Customer"> | $Enums.CreditStatus
    farmSize?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    animalTypes?: JsonNullableWithAggregatesFilter<"Customer">
    henEggsDailyProduction?: IntWithAggregatesFilter<"Customer"> | number
    duckEggsDailyProduction?: IntWithAggregatesFilter<"Customer"> | number
    collectionSchedule?: EnumCollectionScheduleWithAggregatesFilter<"Customer"> | $Enums.CollectionSchedule
    isRetail?: BoolWithAggregatesFilter<"Customer"> | boolean
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    totalPurchases?: IntWithAggregatesFilter<"Customer"> | number
    totalEggSales?: IntWithAggregatesFilter<"Customer"> | number
    lastPurchase?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    lastEggCollection?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    companyName?: StringFilter<"Vendor"> | string
    contactPerson?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    street?: StringNullableFilter<"Vendor"> | string | null
    city?: StringNullableFilter<"Vendor"> | string | null
    state?: StringNullableFilter<"Vendor"> | string | null
    zipCode?: StringNullableFilter<"Vendor"> | string | null
    country?: StringFilter<"Vendor"> | string
    creditLimit?: FloatFilter<"Vendor"> | number
    creditBalance?: FloatFilter<"Vendor"> | number
    paymentTerms?: IntFilter<"Vendor"> | number
    earlyPaymentDiscount?: FloatNullableFilter<"Vendor"> | number | null
    productTypes?: JsonFilter<"Vendor">
    totalPurchases?: FloatFilter<"Vendor"> | number
    onTimePaymentRate?: FloatFilter<"Vendor"> | number
    lastOrder?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    lastPayment?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    active?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    products?: ProductListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrderInput | SortOrder
    productTypes?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
    lastOrder?: SortOrderInput | SortOrder
    lastPayment?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    paymentRecords?: PaymentRecordOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    companyName?: StringFilter<"Vendor"> | string
    contactPerson?: StringFilter<"Vendor"> | string
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    street?: StringNullableFilter<"Vendor"> | string | null
    city?: StringNullableFilter<"Vendor"> | string | null
    state?: StringNullableFilter<"Vendor"> | string | null
    zipCode?: StringNullableFilter<"Vendor"> | string | null
    country?: StringFilter<"Vendor"> | string
    creditLimit?: FloatFilter<"Vendor"> | number
    creditBalance?: FloatFilter<"Vendor"> | number
    paymentTerms?: IntFilter<"Vendor"> | number
    earlyPaymentDiscount?: FloatNullableFilter<"Vendor"> | number | null
    productTypes?: JsonFilter<"Vendor">
    totalPurchases?: FloatFilter<"Vendor"> | number
    onTimePaymentRate?: FloatFilter<"Vendor"> | number
    lastOrder?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    lastPayment?: DateTimeNullableFilter<"Vendor"> | Date | string | null
    active?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    products?: ProductListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    country?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrderInput | SortOrder
    productTypes?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
    lastOrder?: SortOrderInput | SortOrder
    lastPayment?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    companyName?: StringWithAggregatesFilter<"Vendor"> | string
    contactPerson?: StringWithAggregatesFilter<"Vendor"> | string
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    street?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    city?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    state?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    country?: StringWithAggregatesFilter<"Vendor"> | string
    creditLimit?: FloatWithAggregatesFilter<"Vendor"> | number
    creditBalance?: FloatWithAggregatesFilter<"Vendor"> | number
    paymentTerms?: IntWithAggregatesFilter<"Vendor"> | number
    earlyPaymentDiscount?: FloatNullableWithAggregatesFilter<"Vendor"> | number | null
    productTypes?: JsonWithAggregatesFilter<"Vendor">
    totalPurchases?: FloatWithAggregatesFilter<"Vendor"> | number
    onTimePaymentRate?: FloatWithAggregatesFilter<"Vendor"> | number
    lastOrder?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    lastPayment?: DateTimeNullableWithAggregatesFilter<"Vendor"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Vendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    category?: StringFilter<"Product"> | string
    costPrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    wholesalePrice?: FloatNullableFilter<"Product"> | number | null
    stock?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    minimumStock?: IntFilter<"Product"> | number
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    batchNumber?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    requiresPrescription?: BoolFilter<"Product"> | boolean
    activeIngredient?: StringNullableFilter<"Product"> | string | null
    dosage?: StringNullableFilter<"Product"> | string | null
    animalType?: StringNullableFilter<"Product"> | string | null
    nutritionInfo?: StringNullableFilter<"Product"> | string | null
    feedType?: StringNullableFilter<"Product"> | string | null
    primaryVendorId?: StringFilter<"Product"> | string
    alternateVendors?: JsonNullableFilter<"Product">
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    primaryVendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    transactionItems?: TransactionItemListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    unit?: SortOrder
    minimumStock?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    requiresPrescription?: SortOrder
    activeIngredient?: SortOrderInput | SortOrder
    dosage?: SortOrderInput | SortOrder
    animalType?: SortOrderInput | SortOrder
    nutritionInfo?: SortOrderInput | SortOrder
    feedType?: SortOrderInput | SortOrder
    primaryVendorId?: SortOrder
    alternateVendors?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryVendor?: VendorOrderByWithRelationInput
    transactionItems?: TransactionItemOrderByRelationAggregateInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    category?: StringFilter<"Product"> | string
    costPrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    wholesalePrice?: FloatNullableFilter<"Product"> | number | null
    stock?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    minimumStock?: IntFilter<"Product"> | number
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    batchNumber?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    requiresPrescription?: BoolFilter<"Product"> | boolean
    activeIngredient?: StringNullableFilter<"Product"> | string | null
    dosage?: StringNullableFilter<"Product"> | string | null
    animalType?: StringNullableFilter<"Product"> | string | null
    nutritionInfo?: StringNullableFilter<"Product"> | string | null
    feedType?: StringNullableFilter<"Product"> | string | null
    primaryVendorId?: StringFilter<"Product"> | string
    alternateVendors?: JsonNullableFilter<"Product">
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    primaryVendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    transactionItems?: TransactionItemListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    unit?: SortOrder
    minimumStock?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    requiresPrescription?: SortOrder
    activeIngredient?: SortOrderInput | SortOrder
    dosage?: SortOrderInput | SortOrder
    animalType?: SortOrderInput | SortOrder
    nutritionInfo?: SortOrderInput | SortOrder
    feedType?: SortOrderInput | SortOrder
    primaryVendorId?: SortOrder
    alternateVendors?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    category?: StringWithAggregatesFilter<"Product"> | string
    costPrice?: FloatWithAggregatesFilter<"Product"> | number
    sellingPrice?: FloatWithAggregatesFilter<"Product"> | number
    wholesalePrice?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    stock?: IntWithAggregatesFilter<"Product"> | number
    unit?: StringWithAggregatesFilter<"Product"> | string
    minimumStock?: IntWithAggregatesFilter<"Product"> | number
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"Product"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Product"> | string | null
    requiresPrescription?: BoolWithAggregatesFilter<"Product"> | boolean
    activeIngredient?: StringNullableWithAggregatesFilter<"Product"> | string | null
    dosage?: StringNullableWithAggregatesFilter<"Product"> | string | null
    animalType?: StringNullableWithAggregatesFilter<"Product"> | string | null
    nutritionInfo?: StringNullableWithAggregatesFilter<"Product"> | string | null
    feedType?: StringNullableWithAggregatesFilter<"Product"> | string | null
    primaryVendorId?: StringWithAggregatesFilter<"Product"> | string
    alternateVendors?: JsonNullableWithAggregatesFilter<"Product">
    active?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    receiptNumber?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    customerId?: StringNullableFilter<"Transaction"> | string | null
    vendorId?: StringNullableFilter<"Transaction"> | string | null
    subtotal?: FloatFilter<"Transaction"> | number
    tax?: FloatFilter<"Transaction"> | number
    discount?: FloatFilter<"Transaction"> | number
    total?: FloatFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    paidAmount?: FloatFilter<"Transaction"> | number
    balanceAmount?: FloatFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeFilter<"Transaction"> | Date | string
    dueDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    staffId?: StringFilter<"Transaction"> | string
    notes?: StringNullableFilter<"Transaction"> | string | null
    synced?: BoolFilter<"Transaction"> | boolean
    cloudId?: StringNullableFilter<"Transaction"> | string | null
    syncError?: StringNullableFilter<"Transaction"> | string | null
    lastSync?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    items?: TransactionItemListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    staffId?: SortOrder
    notes?: SortOrderInput | SortOrder
    synced?: SortOrder
    cloudId?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    items?: TransactionItemOrderByRelationAggregateInput
    paymentRecords?: PaymentRecordOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNumber?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    customerId?: StringNullableFilter<"Transaction"> | string | null
    vendorId?: StringNullableFilter<"Transaction"> | string | null
    subtotal?: FloatFilter<"Transaction"> | number
    tax?: FloatFilter<"Transaction"> | number
    discount?: FloatFilter<"Transaction"> | number
    total?: FloatFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    paidAmount?: FloatFilter<"Transaction"> | number
    balanceAmount?: FloatFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeFilter<"Transaction"> | Date | string
    dueDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    staffId?: StringFilter<"Transaction"> | string
    notes?: StringNullableFilter<"Transaction"> | string | null
    synced?: BoolFilter<"Transaction"> | boolean
    cloudId?: StringNullableFilter<"Transaction"> | string | null
    syncError?: StringNullableFilter<"Transaction"> | string | null
    lastSync?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    items?: TransactionItemListRelationFilter
    paymentRecords?: PaymentRecordListRelationFilter
  }, "id" | "receiptNumber">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    staffId?: SortOrder
    notes?: SortOrderInput | SortOrder
    synced?: SortOrder
    cloudId?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    receiptNumber?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    customerId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    vendorId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    subtotal?: FloatWithAggregatesFilter<"Transaction"> | number
    tax?: FloatWithAggregatesFilter<"Transaction"> | number
    discount?: FloatWithAggregatesFilter<"Transaction"> | number
    total?: FloatWithAggregatesFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    paidAmount?: FloatWithAggregatesFilter<"Transaction"> | number
    balanceAmount?: FloatWithAggregatesFilter<"Transaction"> | number
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    staffId?: StringWithAggregatesFilter<"Transaction"> | string
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    synced?: BoolWithAggregatesFilter<"Transaction"> | boolean
    cloudId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    syncError?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    lastSync?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TransactionItemWhereInput = {
    AND?: TransactionItemWhereInput | TransactionItemWhereInput[]
    OR?: TransactionItemWhereInput[]
    NOT?: TransactionItemWhereInput | TransactionItemWhereInput[]
    id?: StringFilter<"TransactionItem"> | string
    transactionId?: StringFilter<"TransactionItem"> | string
    productId?: StringFilter<"TransactionItem"> | string
    quantity?: IntFilter<"TransactionItem"> | number
    unitPrice?: IntFilter<"TransactionItem"> | number
    total?: IntFilter<"TransactionItem"> | number
    productName?: StringFilter<"TransactionItem"> | string
    productSku?: StringFilter<"TransactionItem"> | string
    unit?: StringFilter<"TransactionItem"> | string
    batchNumber?: StringNullableFilter<"TransactionItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"TransactionItem"> | Date | string | null
    grade?: StringNullableFilter<"TransactionItem"> | string | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type TransactionItemOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    unit?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type TransactionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionItemWhereInput | TransactionItemWhereInput[]
    OR?: TransactionItemWhereInput[]
    NOT?: TransactionItemWhereInput | TransactionItemWhereInput[]
    transactionId?: StringFilter<"TransactionItem"> | string
    productId?: StringFilter<"TransactionItem"> | string
    quantity?: IntFilter<"TransactionItem"> | number
    unitPrice?: IntFilter<"TransactionItem"> | number
    total?: IntFilter<"TransactionItem"> | number
    productName?: StringFilter<"TransactionItem"> | string
    productSku?: StringFilter<"TransactionItem"> | string
    unit?: StringFilter<"TransactionItem"> | string
    batchNumber?: StringNullableFilter<"TransactionItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"TransactionItem"> | Date | string | null
    grade?: StringNullableFilter<"TransactionItem"> | string | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type TransactionItemOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    unit?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    _count?: TransactionItemCountOrderByAggregateInput
    _avg?: TransactionItemAvgOrderByAggregateInput
    _max?: TransactionItemMaxOrderByAggregateInput
    _min?: TransactionItemMinOrderByAggregateInput
    _sum?: TransactionItemSumOrderByAggregateInput
  }

  export type TransactionItemScalarWhereWithAggregatesInput = {
    AND?: TransactionItemScalarWhereWithAggregatesInput | TransactionItemScalarWhereWithAggregatesInput[]
    OR?: TransactionItemScalarWhereWithAggregatesInput[]
    NOT?: TransactionItemScalarWhereWithAggregatesInput | TransactionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionItem"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionItem"> | string
    productId?: StringWithAggregatesFilter<"TransactionItem"> | string
    quantity?: IntWithAggregatesFilter<"TransactionItem"> | number
    unitPrice?: IntWithAggregatesFilter<"TransactionItem"> | number
    total?: IntWithAggregatesFilter<"TransactionItem"> | number
    productName?: StringWithAggregatesFilter<"TransactionItem"> | string
    productSku?: StringWithAggregatesFilter<"TransactionItem"> | string
    unit?: StringWithAggregatesFilter<"TransactionItem"> | string
    batchNumber?: StringNullableWithAggregatesFilter<"TransactionItem"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"TransactionItem"> | Date | string | null
    grade?: StringNullableWithAggregatesFilter<"TransactionItem"> | string | null
  }

  export type EggCollectionWhereInput = {
    AND?: EggCollectionWhereInput | EggCollectionWhereInput[]
    OR?: EggCollectionWhereInput[]
    NOT?: EggCollectionWhereInput | EggCollectionWhereInput[]
    id?: StringFilter<"EggCollection"> | string
    farmerId?: StringFilter<"EggCollection"> | string
    routeId?: StringNullableFilter<"EggCollection"> | string | null
    staffId?: StringFilter<"EggCollection"> | string
    collectionDate?: DateTimeFilter<"EggCollection"> | Date | string
    henEggsSmall?: IntFilter<"EggCollection"> | number
    henEggsMedium?: IntFilter<"EggCollection"> | number
    henEggsLarge?: IntFilter<"EggCollection"> | number
    henEggsExtraLarge?: IntFilter<"EggCollection"> | number
    henEggsDamaged?: IntFilter<"EggCollection"> | number
    totalHenEggs?: IntFilter<"EggCollection"> | number
    duckEggsSmall?: IntFilter<"EggCollection"> | number
    duckEggsMedium?: IntFilter<"EggCollection"> | number
    duckEggsLarge?: IntFilter<"EggCollection"> | number
    duckEggsDamaged?: IntFilter<"EggCollection"> | number
    totalDuckEggs?: IntFilter<"EggCollection"> | number
    henEggPrice?: FloatFilter<"EggCollection"> | number
    duckEggPrice?: FloatFilter<"EggCollection"> | number
    totalValue?: FloatFilter<"EggCollection"> | number
    qualityScore?: FloatNullableFilter<"EggCollection"> | number | null
    qualityNotes?: StringNullableFilter<"EggCollection"> | string | null
    paid?: BoolFilter<"EggCollection"> | boolean
    paymentDate?: DateTimeNullableFilter<"EggCollection"> | Date | string | null
    synced?: BoolFilter<"EggCollection"> | boolean
    cloudId?: StringNullableFilter<"EggCollection"> | string | null
    syncError?: StringNullableFilter<"EggCollection"> | string | null
    lastSync?: DateTimeNullableFilter<"EggCollection"> | Date | string | null
    createdAt?: DateTimeFilter<"EggCollection"> | Date | string
    updatedAt?: DateTimeFilter<"EggCollection"> | Date | string
    farmer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    route?: XOR<CollectionRouteNullableScalarRelationFilter, CollectionRouteWhereInput> | null
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }

  export type EggCollectionOrderByWithRelationInput = {
    id?: SortOrder
    farmerId?: SortOrder
    routeId?: SortOrderInput | SortOrder
    staffId?: SortOrder
    collectionDate?: SortOrder
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    qualityNotes?: SortOrderInput | SortOrder
    paid?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    synced?: SortOrder
    cloudId?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    farmer?: CustomerOrderByWithRelationInput
    route?: CollectionRouteOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
  }

  export type EggCollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EggCollectionWhereInput | EggCollectionWhereInput[]
    OR?: EggCollectionWhereInput[]
    NOT?: EggCollectionWhereInput | EggCollectionWhereInput[]
    farmerId?: StringFilter<"EggCollection"> | string
    routeId?: StringNullableFilter<"EggCollection"> | string | null
    staffId?: StringFilter<"EggCollection"> | string
    collectionDate?: DateTimeFilter<"EggCollection"> | Date | string
    henEggsSmall?: IntFilter<"EggCollection"> | number
    henEggsMedium?: IntFilter<"EggCollection"> | number
    henEggsLarge?: IntFilter<"EggCollection"> | number
    henEggsExtraLarge?: IntFilter<"EggCollection"> | number
    henEggsDamaged?: IntFilter<"EggCollection"> | number
    totalHenEggs?: IntFilter<"EggCollection"> | number
    duckEggsSmall?: IntFilter<"EggCollection"> | number
    duckEggsMedium?: IntFilter<"EggCollection"> | number
    duckEggsLarge?: IntFilter<"EggCollection"> | number
    duckEggsDamaged?: IntFilter<"EggCollection"> | number
    totalDuckEggs?: IntFilter<"EggCollection"> | number
    henEggPrice?: FloatFilter<"EggCollection"> | number
    duckEggPrice?: FloatFilter<"EggCollection"> | number
    totalValue?: FloatFilter<"EggCollection"> | number
    qualityScore?: FloatNullableFilter<"EggCollection"> | number | null
    qualityNotes?: StringNullableFilter<"EggCollection"> | string | null
    paid?: BoolFilter<"EggCollection"> | boolean
    paymentDate?: DateTimeNullableFilter<"EggCollection"> | Date | string | null
    synced?: BoolFilter<"EggCollection"> | boolean
    cloudId?: StringNullableFilter<"EggCollection"> | string | null
    syncError?: StringNullableFilter<"EggCollection"> | string | null
    lastSync?: DateTimeNullableFilter<"EggCollection"> | Date | string | null
    createdAt?: DateTimeFilter<"EggCollection"> | Date | string
    updatedAt?: DateTimeFilter<"EggCollection"> | Date | string
    farmer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    route?: XOR<CollectionRouteNullableScalarRelationFilter, CollectionRouteWhereInput> | null
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }, "id">

  export type EggCollectionOrderByWithAggregationInput = {
    id?: SortOrder
    farmerId?: SortOrder
    routeId?: SortOrderInput | SortOrder
    staffId?: SortOrder
    collectionDate?: SortOrder
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrderInput | SortOrder
    qualityNotes?: SortOrderInput | SortOrder
    paid?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    synced?: SortOrder
    cloudId?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EggCollectionCountOrderByAggregateInput
    _avg?: EggCollectionAvgOrderByAggregateInput
    _max?: EggCollectionMaxOrderByAggregateInput
    _min?: EggCollectionMinOrderByAggregateInput
    _sum?: EggCollectionSumOrderByAggregateInput
  }

  export type EggCollectionScalarWhereWithAggregatesInput = {
    AND?: EggCollectionScalarWhereWithAggregatesInput | EggCollectionScalarWhereWithAggregatesInput[]
    OR?: EggCollectionScalarWhereWithAggregatesInput[]
    NOT?: EggCollectionScalarWhereWithAggregatesInput | EggCollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EggCollection"> | string
    farmerId?: StringWithAggregatesFilter<"EggCollection"> | string
    routeId?: StringNullableWithAggregatesFilter<"EggCollection"> | string | null
    staffId?: StringWithAggregatesFilter<"EggCollection"> | string
    collectionDate?: DateTimeWithAggregatesFilter<"EggCollection"> | Date | string
    henEggsSmall?: IntWithAggregatesFilter<"EggCollection"> | number
    henEggsMedium?: IntWithAggregatesFilter<"EggCollection"> | number
    henEggsLarge?: IntWithAggregatesFilter<"EggCollection"> | number
    henEggsExtraLarge?: IntWithAggregatesFilter<"EggCollection"> | number
    henEggsDamaged?: IntWithAggregatesFilter<"EggCollection"> | number
    totalHenEggs?: IntWithAggregatesFilter<"EggCollection"> | number
    duckEggsSmall?: IntWithAggregatesFilter<"EggCollection"> | number
    duckEggsMedium?: IntWithAggregatesFilter<"EggCollection"> | number
    duckEggsLarge?: IntWithAggregatesFilter<"EggCollection"> | number
    duckEggsDamaged?: IntWithAggregatesFilter<"EggCollection"> | number
    totalDuckEggs?: IntWithAggregatesFilter<"EggCollection"> | number
    henEggPrice?: FloatWithAggregatesFilter<"EggCollection"> | number
    duckEggPrice?: FloatWithAggregatesFilter<"EggCollection"> | number
    totalValue?: FloatWithAggregatesFilter<"EggCollection"> | number
    qualityScore?: FloatNullableWithAggregatesFilter<"EggCollection"> | number | null
    qualityNotes?: StringNullableWithAggregatesFilter<"EggCollection"> | string | null
    paid?: BoolWithAggregatesFilter<"EggCollection"> | boolean
    paymentDate?: DateTimeNullableWithAggregatesFilter<"EggCollection"> | Date | string | null
    synced?: BoolWithAggregatesFilter<"EggCollection"> | boolean
    cloudId?: StringNullableWithAggregatesFilter<"EggCollection"> | string | null
    syncError?: StringNullableWithAggregatesFilter<"EggCollection"> | string | null
    lastSync?: DateTimeNullableWithAggregatesFilter<"EggCollection"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EggCollection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EggCollection"> | Date | string
  }

  export type CollectionRouteWhereInput = {
    AND?: CollectionRouteWhereInput | CollectionRouteWhereInput[]
    OR?: CollectionRouteWhereInput[]
    NOT?: CollectionRouteWhereInput | CollectionRouteWhereInput[]
    id?: StringFilter<"CollectionRoute"> | string
    name?: StringFilter<"CollectionRoute"> | string
    description?: StringNullableFilter<"CollectionRoute"> | string | null
    estimatedTime?: IntFilter<"CollectionRoute"> | number
    estimatedDistance?: FloatFilter<"CollectionRoute"> | number
    schedule?: EnumCollectionScheduleFilter<"CollectionRoute"> | $Enums.CollectionSchedule
    staffId?: StringNullableFilter<"CollectionRoute"> | string | null
    averageTime?: IntNullableFilter<"CollectionRoute"> | number | null
    onTimePercentage?: FloatNullableFilter<"CollectionRoute"> | number | null
    totalCollections?: IntFilter<"CollectionRoute"> | number
    active?: BoolFilter<"CollectionRoute"> | boolean
    createdAt?: DateTimeFilter<"CollectionRoute"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionRoute"> | Date | string
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    customers?: CustomerListRelationFilter
    eggCollections?: EggCollectionListRelationFilter
  }

  export type CollectionRouteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    schedule?: SortOrder
    staffId?: SortOrderInput | SortOrder
    averageTime?: SortOrderInput | SortOrder
    onTimePercentage?: SortOrderInput | SortOrder
    totalCollections?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
    customers?: CustomerOrderByRelationAggregateInput
    eggCollections?: EggCollectionOrderByRelationAggregateInput
  }

  export type CollectionRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionRouteWhereInput | CollectionRouteWhereInput[]
    OR?: CollectionRouteWhereInput[]
    NOT?: CollectionRouteWhereInput | CollectionRouteWhereInput[]
    name?: StringFilter<"CollectionRoute"> | string
    description?: StringNullableFilter<"CollectionRoute"> | string | null
    estimatedTime?: IntFilter<"CollectionRoute"> | number
    estimatedDistance?: FloatFilter<"CollectionRoute"> | number
    schedule?: EnumCollectionScheduleFilter<"CollectionRoute"> | $Enums.CollectionSchedule
    staffId?: StringNullableFilter<"CollectionRoute"> | string | null
    averageTime?: IntNullableFilter<"CollectionRoute"> | number | null
    onTimePercentage?: FloatNullableFilter<"CollectionRoute"> | number | null
    totalCollections?: IntFilter<"CollectionRoute"> | number
    active?: BoolFilter<"CollectionRoute"> | boolean
    createdAt?: DateTimeFilter<"CollectionRoute"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionRoute"> | Date | string
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    customers?: CustomerListRelationFilter
    eggCollections?: EggCollectionListRelationFilter
  }, "id">

  export type CollectionRouteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    schedule?: SortOrder
    staffId?: SortOrderInput | SortOrder
    averageTime?: SortOrderInput | SortOrder
    onTimePercentage?: SortOrderInput | SortOrder
    totalCollections?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionRouteCountOrderByAggregateInput
    _avg?: CollectionRouteAvgOrderByAggregateInput
    _max?: CollectionRouteMaxOrderByAggregateInput
    _min?: CollectionRouteMinOrderByAggregateInput
    _sum?: CollectionRouteSumOrderByAggregateInput
  }

  export type CollectionRouteScalarWhereWithAggregatesInput = {
    AND?: CollectionRouteScalarWhereWithAggregatesInput | CollectionRouteScalarWhereWithAggregatesInput[]
    OR?: CollectionRouteScalarWhereWithAggregatesInput[]
    NOT?: CollectionRouteScalarWhereWithAggregatesInput | CollectionRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionRoute"> | string
    name?: StringWithAggregatesFilter<"CollectionRoute"> | string
    description?: StringNullableWithAggregatesFilter<"CollectionRoute"> | string | null
    estimatedTime?: IntWithAggregatesFilter<"CollectionRoute"> | number
    estimatedDistance?: FloatWithAggregatesFilter<"CollectionRoute"> | number
    schedule?: EnumCollectionScheduleWithAggregatesFilter<"CollectionRoute"> | $Enums.CollectionSchedule
    staffId?: StringNullableWithAggregatesFilter<"CollectionRoute"> | string | null
    averageTime?: IntNullableWithAggregatesFilter<"CollectionRoute"> | number | null
    onTimePercentage?: FloatNullableWithAggregatesFilter<"CollectionRoute"> | number | null
    totalCollections?: IntWithAggregatesFilter<"CollectionRoute"> | number
    active?: BoolWithAggregatesFilter<"CollectionRoute"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CollectionRoute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionRoute"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    vendorId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: FloatFilter<"PurchaseOrder"> | number
    tax?: FloatFilter<"PurchaseOrder"> | number
    shipping?: FloatFilter<"PurchaseOrder"> | number
    total?: FloatFilter<"PurchaseOrder"> | number
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    orderedBy?: StringFilter<"PurchaseOrder"> | string
    receivedBy?: StringNullableFilter<"PurchaseOrder"> | string | null
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    synced?: BoolFilter<"PurchaseOrder"> | boolean
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    status?: SortOrder
    orderedBy?: SortOrder
    receivedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    vendorId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: FloatFilter<"PurchaseOrder"> | number
    tax?: FloatFilter<"PurchaseOrder"> | number
    shipping?: FloatFilter<"PurchaseOrder"> | number
    total?: FloatFilter<"PurchaseOrder"> | number
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    orderedBy?: StringFilter<"PurchaseOrder"> | string
    receivedBy?: StringNullableFilter<"PurchaseOrder"> | string | null
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    synced?: BoolFilter<"PurchaseOrder"> | boolean
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }, "id" | "orderNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    status?: SortOrder
    orderedBy?: SortOrder
    receivedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    vendorId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    tax?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    shipping?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    total?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    status?: EnumPurchaseOrderStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    orderedBy?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    receivedBy?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    synced?: BoolWithAggregatesFilter<"PurchaseOrder"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantityOrdered?: IntFilter<"PurchaseOrderItem"> | number
    quantityReceived?: IntFilter<"PurchaseOrderItem"> | number
    unitCost?: FloatFilter<"PurchaseOrderItem"> | number
    totalCost?: FloatFilter<"PurchaseOrderItem"> | number
    productName?: StringFilter<"PurchaseOrderItem"> | string
    productSku?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantityOrdered?: IntFilter<"PurchaseOrderItem"> | number
    quantityReceived?: IntFilter<"PurchaseOrderItem"> | number
    unitCost?: FloatFilter<"PurchaseOrderItem"> | number
    totalCost?: FloatFilter<"PurchaseOrderItem"> | number
    productName?: StringFilter<"PurchaseOrderItem"> | string
    productSku?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    quantityOrdered?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    quantityReceived?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    unitCost?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    totalCost?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    productName?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    productSku?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
  }

  export type PaymentRecordWhereInput = {
    AND?: PaymentRecordWhereInput | PaymentRecordWhereInput[]
    OR?: PaymentRecordWhereInput[]
    NOT?: PaymentRecordWhereInput | PaymentRecordWhereInput[]
    id?: StringFilter<"PaymentRecord"> | string
    type?: EnumPaymentTypeFilter<"PaymentRecord"> | $Enums.PaymentType
    amount?: FloatFilter<"PaymentRecord"> | number
    customerId?: StringNullableFilter<"PaymentRecord"> | string | null
    vendorId?: StringNullableFilter<"PaymentRecord"> | string | null
    transactionId?: StringNullableFilter<"PaymentRecord"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PaymentRecord"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"PaymentRecord"> | Date | string
    dueDate?: DateTimeNullableFilter<"PaymentRecord"> | Date | string | null
    referenceNumber?: StringNullableFilter<"PaymentRecord"> | string | null
    checkNumber?: StringNullableFilter<"PaymentRecord"> | string | null
    processedBy?: StringFilter<"PaymentRecord"> | string
    notes?: StringNullableFilter<"PaymentRecord"> | string | null
    synced?: BoolFilter<"PaymentRecord"> | boolean
    createdAt?: DateTimeFilter<"PaymentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRecord"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }

  export type PaymentRecordOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    customerId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    checkNumber?: SortOrderInput | SortOrder
    processedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
  }

  export type PaymentRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentRecordWhereInput | PaymentRecordWhereInput[]
    OR?: PaymentRecordWhereInput[]
    NOT?: PaymentRecordWhereInput | PaymentRecordWhereInput[]
    type?: EnumPaymentTypeFilter<"PaymentRecord"> | $Enums.PaymentType
    amount?: FloatFilter<"PaymentRecord"> | number
    customerId?: StringNullableFilter<"PaymentRecord"> | string | null
    vendorId?: StringNullableFilter<"PaymentRecord"> | string | null
    transactionId?: StringNullableFilter<"PaymentRecord"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PaymentRecord"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"PaymentRecord"> | Date | string
    dueDate?: DateTimeNullableFilter<"PaymentRecord"> | Date | string | null
    referenceNumber?: StringNullableFilter<"PaymentRecord"> | string | null
    checkNumber?: StringNullableFilter<"PaymentRecord"> | string | null
    processedBy?: StringFilter<"PaymentRecord"> | string
    notes?: StringNullableFilter<"PaymentRecord"> | string | null
    synced?: BoolFilter<"PaymentRecord"> | boolean
    createdAt?: DateTimeFilter<"PaymentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRecord"> | Date | string
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    vendor?: XOR<VendorNullableScalarRelationFilter, VendorWhereInput> | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }, "id">

  export type PaymentRecordOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    customerId?: SortOrderInput | SortOrder
    vendorId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    checkNumber?: SortOrderInput | SortOrder
    processedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentRecordCountOrderByAggregateInput
    _avg?: PaymentRecordAvgOrderByAggregateInput
    _max?: PaymentRecordMaxOrderByAggregateInput
    _min?: PaymentRecordMinOrderByAggregateInput
    _sum?: PaymentRecordSumOrderByAggregateInput
  }

  export type PaymentRecordScalarWhereWithAggregatesInput = {
    AND?: PaymentRecordScalarWhereWithAggregatesInput | PaymentRecordScalarWhereWithAggregatesInput[]
    OR?: PaymentRecordScalarWhereWithAggregatesInput[]
    NOT?: PaymentRecordScalarWhereWithAggregatesInput | PaymentRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentRecord"> | string
    type?: EnumPaymentTypeWithAggregatesFilter<"PaymentRecord"> | $Enums.PaymentType
    amount?: FloatWithAggregatesFilter<"PaymentRecord"> | number
    customerId?: StringNullableWithAggregatesFilter<"PaymentRecord"> | string | null
    vendorId?: StringNullableWithAggregatesFilter<"PaymentRecord"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"PaymentRecord"> | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"PaymentRecord"> | $Enums.PaymentMethod
    paymentDate?: DateTimeWithAggregatesFilter<"PaymentRecord"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"PaymentRecord"> | Date | string | null
    referenceNumber?: StringNullableWithAggregatesFilter<"PaymentRecord"> | string | null
    checkNumber?: StringNullableWithAggregatesFilter<"PaymentRecord"> | string | null
    processedBy?: StringWithAggregatesFilter<"PaymentRecord"> | string
    notes?: StringNullableWithAggregatesFilter<"PaymentRecord"> | string | null
    synced?: BoolWithAggregatesFilter<"PaymentRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentRecord"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    type?: EnumSettingTypeFilter<"SystemSetting"> | $Enums.SettingType
    description?: StringNullableFilter<"SystemSetting"> | string | null
    category?: StringFilter<"SystemSetting"> | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: StringNullableFilter<"SystemSetting"> | string | null
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    type?: EnumSettingTypeFilter<"SystemSetting"> | $Enums.SettingType
    description?: StringNullableFilter<"SystemSetting"> | string | null
    category?: StringFilter<"SystemSetting"> | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: StringNullableFilter<"SystemSetting"> | string | null
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    type?: EnumSettingTypeWithAggregatesFilter<"SystemSetting"> | $Enums.SettingType
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    category?: StringWithAggregatesFilter<"SystemSetting"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    tableName?: StringFilter<"SyncLog"> | string
    recordId?: StringFilter<"SyncLog"> | string
    operation?: EnumSyncOperationFilter<"SyncLog"> | $Enums.SyncOperation
    syncedAt?: DateTimeFilter<"SyncLog"> | Date | string
    success?: BoolFilter<"SyncLog"> | boolean
    error?: StringNullableFilter<"SyncLog"> | string | null
    attempts?: IntFilter<"SyncLog"> | number
    conflictResolution?: StringNullableFilter<"SyncLog"> | string | null
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    syncedAt?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    attempts?: SortOrder
    conflictResolution?: SortOrderInput | SortOrder
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    tableName?: StringFilter<"SyncLog"> | string
    recordId?: StringFilter<"SyncLog"> | string
    operation?: EnumSyncOperationFilter<"SyncLog"> | $Enums.SyncOperation
    syncedAt?: DateTimeFilter<"SyncLog"> | Date | string
    success?: BoolFilter<"SyncLog"> | boolean
    error?: StringNullableFilter<"SyncLog"> | string | null
    attempts?: IntFilter<"SyncLog"> | number
    conflictResolution?: StringNullableFilter<"SyncLog"> | string | null
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    syncedAt?: SortOrder
    success?: SortOrder
    error?: SortOrderInput | SortOrder
    attempts?: SortOrder
    conflictResolution?: SortOrderInput | SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _avg?: SyncLogAvgOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
    _sum?: SyncLogSumOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    tableName?: StringWithAggregatesFilter<"SyncLog"> | string
    recordId?: StringWithAggregatesFilter<"SyncLog"> | string
    operation?: EnumSyncOperationWithAggregatesFilter<"SyncLog"> | $Enums.SyncOperation
    syncedAt?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
    success?: BoolWithAggregatesFilter<"SyncLog"> | boolean
    error?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    attempts?: IntWithAggregatesFilter<"SyncLog"> | number
    conflictResolution?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"Notification"> | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientIds?: JsonNullableFilter<"Notification">
    globalNotification?: BoolFilter<"Notification"> | boolean
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readBy?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    actionRequired?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionData?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientIds?: SortOrderInput | SortOrder
    globalNotification?: SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    readBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"Notification"> | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    recipientIds?: JsonNullableFilter<"Notification">
    globalNotification?: BoolFilter<"Notification"> | boolean
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readBy?: StringNullableFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    actionRequired?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionData?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientIds?: SortOrderInput | SortOrder
    globalNotification?: SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    readBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryWithAggregatesFilter<"Notification"> | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    recipientIds?: JsonNullableWithAggregatesFilter<"Notification">
    globalNotification?: BoolWithAggregatesFilter<"Notification"> | boolean
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readBy?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    actionRequired?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionData?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type StoreCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    email?: string | null
    website?: string | null
    taxRate?: number
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    printLogo?: boolean
    logoData?: string | null
    creditTermsDefault?: number
    maxCreditLimit?: number
    interestRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    email?: string | null
    website?: string | null
    taxRate?: number
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    printLogo?: boolean
    logoData?: string | null
    creditTermsDefault?: number
    maxCreditLimit?: number
    interestRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    printLogo?: BoolFieldUpdateOperationsInput | boolean
    logoData?: NullableStringFieldUpdateOperationsInput | string | null
    creditTermsDefault?: IntFieldUpdateOperationsInput | number
    maxCreditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    printLogo?: BoolFieldUpdateOperationsInput | boolean
    logoData?: NullableStringFieldUpdateOperationsInput | string | null
    creditTermsDefault?: IntFieldUpdateOperationsInput | number
    maxCreditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateManyInput = {
    id?: string
    name: string
    address: string
    phone: string
    email?: string | null
    website?: string | null
    taxRate?: number
    currency?: string
    timezone?: string
    receiptHeader?: string | null
    receiptFooter?: string | null
    printLogo?: boolean
    logoData?: string | null
    creditTermsDefault?: number
    maxCreditLimit?: number
    interestRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    printLogo?: BoolFieldUpdateOperationsInput | boolean
    logoData?: NullableStringFieldUpdateOperationsInput | string | null
    creditTermsDefault?: IntFieldUpdateOperationsInput | number
    maxCreditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    receiptHeader?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    printLogo?: BoolFieldUpdateOperationsInput | boolean
    logoData?: NullableStringFieldUpdateOperationsInput | string | null
    creditTermsDefault?: IntFieldUpdateOperationsInput | number
    maxCreditLimit?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteUncheckedCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUncheckedUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    eggCollections?: EggCollectionCreateNestedManyWithoutFarmerInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutCustomerInput
    routes?: CollectionRouteCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutFarmerInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutCustomerInput
    routes?: CollectionRouteUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutFarmerNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutCustomerNestedInput
    routes?: CollectionRouteUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutFarmerNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutCustomerNestedInput
    routes?: CollectionRouteUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutPrimaryVendorInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutVendorInput
    Transaction?: TransactionCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPrimaryVendorInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutVendorInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutPrimaryVendorNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPrimaryVendorNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryVendor: VendorCreateNestedOneWithoutProductsInput
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    primaryVendorId: string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryVendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryVendorId?: StringFieldUpdateOperationsInput | string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    primaryVendorId: string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryVendorId?: StringFieldUpdateOperationsInput | string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    vendor?: VendorCreateNestedOneWithoutTransactionInput
    staff: StaffCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    vendor?: VendorUpdateOneWithoutTransactionNestedInput
    staff?: StaffUpdateOneRequiredWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
    transaction: TransactionCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutTransactionItemsInput
  }

  export type TransactionItemUncheckedCreateInput = {
    id?: string
    transactionId: string
    productId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
  }

  export type TransactionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransactionItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionItemCreateManyInput = {
    id?: string
    transactionId: string
    productId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
  }

  export type TransactionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EggCollectionCreateInput = {
    id?: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    farmer: CustomerCreateNestedOneWithoutEggCollectionsInput
    route?: CollectionRouteCreateNestedOneWithoutEggCollectionsInput
    staff: StaffCreateNestedOneWithoutEggCollectionsInput
  }

  export type EggCollectionUncheckedCreateInput = {
    id?: string
    farmerId: string
    routeId?: string | null
    staffId: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: CustomerUpdateOneRequiredWithoutEggCollectionsNestedInput
    route?: CollectionRouteUpdateOneWithoutEggCollectionsNestedInput
    staff?: StaffUpdateOneRequiredWithoutEggCollectionsNestedInput
  }

  export type EggCollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmerId?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionCreateManyInput = {
    id?: string
    farmerId: string
    routeId?: string | null
    staffId: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmerId?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionRouteCreateInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutCollectionRoutesInput
    customers?: CustomerCreateNestedManyWithoutRoutesInput
    eggCollections?: EggCollectionCreateNestedManyWithoutRouteInput
  }

  export type CollectionRouteUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    staffId?: string | null
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutRoutesInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutRouteInput
  }

  export type CollectionRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutCollectionRoutesNestedInput
    customers?: CustomerUpdateManyWithoutRoutesNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutRouteNestedInput
  }

  export type CollectionRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutRoutesNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type CollectionRouteCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    staffId?: string | null
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseOrdersInput
    staff: StaffCreateNestedOneWithoutPurchaseOrderInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    vendorId: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    orderedBy: string
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    staff?: StaffUpdateOneRequiredWithoutPurchaseOrderNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    orderedBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    orderNumber: string
    vendorId: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    orderedBy: string
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    orderedBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentRecordCreateInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPaymentRecordsInput
    vendor?: VendorCreateNestedOneWithoutPaymentRecordsInput
    transaction?: TransactionCreateNestedOneWithoutPaymentRecordsInput
    staff: StaffCreateNestedOneWithoutPaymentRecordsInput
  }

  export type PaymentRecordUncheckedCreateInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    vendorId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPaymentRecordsNestedInput
    vendor?: VendorUpdateOneWithoutPaymentRecordsNestedInput
    transaction?: TransactionUpdateOneWithoutPaymentRecordsNestedInput
    staff?: StaffUpdateOneRequiredWithoutPaymentRecordsNestedInput
  }

  export type PaymentRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordCreateManyInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    vendorId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    type?: $Enums.SettingType
    description?: string | null
    category?: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    type?: $Enums.SettingType
    description?: string | null
    category?: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    type?: $Enums.SettingType
    description?: string | null
    category?: string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    action: $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.SyncOperation
    syncedAt?: Date | string
    success: boolean
    error?: string | null
    attempts?: number
    conflictResolution?: string | null
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.SyncOperation
    syncedAt?: Date | string
    success: boolean
    error?: string | null
    attempts?: number
    conflictResolution?: string | null
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    conflictResolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    conflictResolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncLogCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.SyncOperation
    syncedAt?: Date | string
    success: boolean
    error?: string | null
    attempts?: number
    conflictResolution?: string | null
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    conflictResolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    conflictResolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    priority?: $Enums.NotificationPriority
    title: string
    message: string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: boolean
    read?: boolean
    readAt?: Date | string | null
    readBy?: string | null
    expiresAt?: Date | string | null
    actionRequired?: boolean
    actionUrl?: string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    priority?: $Enums.NotificationPriority
    title: string
    message: string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: boolean
    read?: boolean
    readAt?: Date | string | null
    readBy?: string | null
    expiresAt?: Date | string | null
    actionRequired?: boolean
    actionUrl?: string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    priority?: $Enums.NotificationPriority
    title: string
    message: string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: boolean
    read?: boolean
    readAt?: Date | string | null
    readBy?: string | null
    expiresAt?: Date | string | null
    actionRequired?: boolean
    actionUrl?: string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientIds?: NullableJsonNullValueInput | InputJsonValue
    globalNotification?: BoolFieldUpdateOperationsInput | boolean
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrder
    receiptFooter?: SortOrder
    printLogo?: SortOrder
    logoData?: SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrder
    receiptFooter?: SortOrder
    printLogo?: SortOrder
    logoData?: SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    receiptHeader?: SortOrder
    receiptFooter?: SortOrder
    printLogo?: SortOrder
    logoData?: SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    taxRate?: SortOrder
    creditTermsDefault?: SortOrder
    maxCreditLimit?: SortOrder
    interestRate?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumStaffPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffPosition | EnumStaffPositionFieldRefInput<$PrismaModel>
    in?: $Enums.StaffPosition[]
    notIn?: $Enums.StaffPosition[]
    not?: NestedEnumStaffPositionFilter<$PrismaModel> | $Enums.StaffPosition
  }

  export type EnumStaffDepartmentFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffDepartment | EnumStaffDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.StaffDepartment[]
    notIn?: $Enums.StaffDepartment[]
    not?: NestedEnumStaffDepartmentFilter<$PrismaModel> | $Enums.StaffDepartment
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type EggCollectionListRelationFilter = {
    every?: EggCollectionWhereInput
    some?: EggCollectionWhereInput
    none?: EggCollectionWhereInput
  }

  export type PaymentRecordListRelationFilter = {
    every?: PaymentRecordWhereInput
    some?: PaymentRecordWhereInput
    none?: PaymentRecordWhereInput
  }

  export type CollectionRouteListRelationFilter = {
    every?: CollectionRouteWhereInput
    some?: CollectionRouteWhereInput
    none?: CollectionRouteWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EggCollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    active?: SortOrder
    username?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    permissions?: SortOrder
    totalCollections?: SortOrder
    averageQuality?: SortOrder
    onTimeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAvgOrderByAggregateInput = {
    salary?: SortOrder
    totalCollections?: SortOrder
    averageQuality?: SortOrder
    onTimeRate?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    active?: SortOrder
    username?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    totalCollections?: SortOrder
    averageQuality?: SortOrder
    onTimeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    active?: SortOrder
    username?: SortOrder
    password?: SortOrder
    lastLogin?: SortOrder
    totalCollections?: SortOrder
    averageQuality?: SortOrder
    onTimeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffSumOrderByAggregateInput = {
    salary?: SortOrder
    totalCollections?: SortOrder
    averageQuality?: SortOrder
    onTimeRate?: SortOrder
  }

  export type EnumStaffPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffPosition | EnumStaffPositionFieldRefInput<$PrismaModel>
    in?: $Enums.StaffPosition[]
    notIn?: $Enums.StaffPosition[]
    not?: NestedEnumStaffPositionWithAggregatesFilter<$PrismaModel> | $Enums.StaffPosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffPositionFilter<$PrismaModel>
    _max?: NestedEnumStaffPositionFilter<$PrismaModel>
  }

  export type EnumStaffDepartmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffDepartment | EnumStaffDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.StaffDepartment[]
    notIn?: $Enums.StaffDepartment[]
    not?: NestedEnumStaffDepartmentWithAggregatesFilter<$PrismaModel> | $Enums.StaffDepartment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffDepartmentFilter<$PrismaModel>
    _max?: NestedEnumStaffDepartmentFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type EnumCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusFilter<$PrismaModel> | $Enums.CreditStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumCollectionScheduleFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionSchedule | EnumCollectionScheduleFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionSchedule[]
    notIn?: $Enums.CollectionSchedule[]
    not?: NestedEnumCollectionScheduleFilter<$PrismaModel> | $Enums.CollectionSchedule
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    businessName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    creditStatus?: SortOrder
    farmSize?: SortOrder
    animalTypes?: SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    collectionSchedule?: SortOrder
    isRetail?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
    lastPurchase?: SortOrder
    lastEggCollection?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    farmSize?: SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    businessName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    creditStatus?: SortOrder
    farmSize?: SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    collectionSchedule?: SortOrder
    isRetail?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
    lastPurchase?: SortOrder
    lastEggCollection?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    businessName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    creditStatus?: SortOrder
    farmSize?: SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    collectionSchedule?: SortOrder
    isRetail?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
    lastPurchase?: SortOrder
    lastEggCollection?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    farmSize?: SortOrder
    henEggsDailyProduction?: SortOrder
    duckEggsDailyProduction?: SortOrder
    loyaltyPoints?: SortOrder
    totalPurchases?: SortOrder
    totalEggSales?: SortOrder
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type EnumCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCollectionScheduleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionSchedule | EnumCollectionScheduleFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionSchedule[]
    notIn?: $Enums.CollectionSchedule[]
    not?: NestedEnumCollectionScheduleWithAggregatesFilter<$PrismaModel> | $Enums.CollectionSchedule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionScheduleFilter<$PrismaModel>
    _max?: NestedEnumCollectionScheduleFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrder
    productTypes?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
    lastOrder?: SortOrder
    lastPayment?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
    lastOrder?: SortOrder
    lastPayment?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
    lastOrder?: SortOrder
    lastPayment?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    creditLimit?: SortOrder
    creditBalance?: SortOrder
    paymentTerms?: SortOrder
    earlyPaymentDiscount?: SortOrder
    totalPurchases?: SortOrder
    onTimePaymentRate?: SortOrder
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type TransactionItemListRelationFilter = {
    every?: TransactionItemWhereInput
    some?: TransactionItemWhereInput
    none?: TransactionItemWhereInput
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type TransactionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    stock?: SortOrder
    unit?: SortOrder
    minimumStock?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    manufacturer?: SortOrder
    requiresPrescription?: SortOrder
    activeIngredient?: SortOrder
    dosage?: SortOrder
    animalType?: SortOrder
    nutritionInfo?: SortOrder
    feedType?: SortOrder
    primaryVendorId?: SortOrder
    alternateVendors?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    stock?: SortOrder
    minimumStock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    stock?: SortOrder
    unit?: SortOrder
    minimumStock?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    manufacturer?: SortOrder
    requiresPrescription?: SortOrder
    activeIngredient?: SortOrder
    dosage?: SortOrder
    animalType?: SortOrder
    nutritionInfo?: SortOrder
    feedType?: SortOrder
    primaryVendorId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    stock?: SortOrder
    unit?: SortOrder
    minimumStock?: SortOrder
    expiryDate?: SortOrder
    batchNumber?: SortOrder
    manufacturer?: SortOrder
    requiresPrescription?: SortOrder
    activeIngredient?: SortOrder
    dosage?: SortOrder
    animalType?: SortOrder
    nutritionInfo?: SortOrder
    feedType?: SortOrder
    primaryVendorId?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    stock?: SortOrder
    minimumStock?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type VendorNullableScalarRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type StaffScalarRelationFilter = {
    is?: StaffWhereInput
    isNot?: StaffWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    dueDate?: SortOrder
    staffId?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    cloudId?: SortOrder
    syncError?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    dueDate?: SortOrder
    staffId?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    cloudId?: SortOrder
    syncError?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    type?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    dueDate?: SortOrder
    staffId?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    cloudId?: SortOrder
    syncError?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceAmount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type TransactionItemCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    unit?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    grade?: SortOrder
  }

  export type TransactionItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type TransactionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    unit?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    grade?: SortOrder
  }

  export type TransactionItemMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
    unit?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    grade?: SortOrder
  }

  export type TransactionItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CollectionRouteNullableScalarRelationFilter = {
    is?: CollectionRouteWhereInput | null
    isNot?: CollectionRouteWhereInput | null
  }

  export type EggCollectionCountOrderByAggregateInput = {
    id?: SortOrder
    farmerId?: SortOrder
    routeId?: SortOrder
    staffId?: SortOrder
    collectionDate?: SortOrder
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrder
    qualityNotes?: SortOrder
    paid?: SortOrder
    paymentDate?: SortOrder
    synced?: SortOrder
    cloudId?: SortOrder
    syncError?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EggCollectionAvgOrderByAggregateInput = {
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrder
  }

  export type EggCollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    farmerId?: SortOrder
    routeId?: SortOrder
    staffId?: SortOrder
    collectionDate?: SortOrder
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrder
    qualityNotes?: SortOrder
    paid?: SortOrder
    paymentDate?: SortOrder
    synced?: SortOrder
    cloudId?: SortOrder
    syncError?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EggCollectionMinOrderByAggregateInput = {
    id?: SortOrder
    farmerId?: SortOrder
    routeId?: SortOrder
    staffId?: SortOrder
    collectionDate?: SortOrder
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrder
    qualityNotes?: SortOrder
    paid?: SortOrder
    paymentDate?: SortOrder
    synced?: SortOrder
    cloudId?: SortOrder
    syncError?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EggCollectionSumOrderByAggregateInput = {
    henEggsSmall?: SortOrder
    henEggsMedium?: SortOrder
    henEggsLarge?: SortOrder
    henEggsExtraLarge?: SortOrder
    henEggsDamaged?: SortOrder
    totalHenEggs?: SortOrder
    duckEggsSmall?: SortOrder
    duckEggsMedium?: SortOrder
    duckEggsLarge?: SortOrder
    duckEggsDamaged?: SortOrder
    totalDuckEggs?: SortOrder
    henEggPrice?: SortOrder
    duckEggPrice?: SortOrder
    totalValue?: SortOrder
    qualityScore?: SortOrder
  }

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionRouteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    schedule?: SortOrder
    staffId?: SortOrder
    averageTime?: SortOrder
    onTimePercentage?: SortOrder
    totalCollections?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionRouteAvgOrderByAggregateInput = {
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    averageTime?: SortOrder
    onTimePercentage?: SortOrder
    totalCollections?: SortOrder
  }

  export type CollectionRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    schedule?: SortOrder
    staffId?: SortOrder
    averageTime?: SortOrder
    onTimePercentage?: SortOrder
    totalCollections?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionRouteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    schedule?: SortOrder
    staffId?: SortOrder
    averageTime?: SortOrder
    onTimePercentage?: SortOrder
    totalCollections?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionRouteSumOrderByAggregateInput = {
    estimatedTime?: SortOrder
    estimatedDistance?: SortOrder
    averageTime?: SortOrder
    onTimePercentage?: SortOrder
    totalCollections?: SortOrder
  }

  export type EnumPurchaseOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[]
    notIn?: $Enums.PurchaseOrderStatus[]
    not?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    status?: SortOrder
    orderedBy?: SortOrder
    receivedBy?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    status?: SortOrder
    orderedBy?: SortOrder
    receivedBy?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
    status?: SortOrder
    orderedBy?: SortOrder
    receivedBy?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    shipping?: SortOrder
    total?: SortOrder
  }

  export type EnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[]
    notIn?: $Enums.PurchaseOrderStatus[]
    not?: NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    productName?: SortOrder
    productSku?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    quantityOrdered?: SortOrder
    quantityReceived?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[]
    notIn?: $Enums.PaymentType[]
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type PaymentRecordCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    referenceNumber?: SortOrder
    checkNumber?: SortOrder
    processedBy?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    referenceNumber?: SortOrder
    checkNumber?: SortOrder
    processedBy?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRecordMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    customerId?: SortOrder
    vendorId?: SortOrder
    transactionId?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    dueDate?: SortOrder
    referenceNumber?: SortOrder
    checkNumber?: SortOrder
    processedBy?: SortOrder
    notes?: SortOrder
    synced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[]
    notIn?: $Enums.PaymentType[]
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type EnumSettingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeFilter<$PrismaModel> | $Enums.SettingType
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    description?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    description?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    description?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumSettingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeWithAggregatesFilter<$PrismaModel> | $Enums.SettingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSettingTypeFilter<$PrismaModel>
    _max?: NestedEnumSettingTypeFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumSyncOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationFilter<$PrismaModel> | $Enums.SyncOperation
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    syncedAt?: SortOrder
    success?: SortOrder
    error?: SortOrder
    attempts?: SortOrder
    conflictResolution?: SortOrder
  }

  export type SyncLogAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    syncedAt?: SortOrder
    success?: SortOrder
    error?: SortOrder
    attempts?: SortOrder
    conflictResolution?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    syncedAt?: SortOrder
    success?: SortOrder
    error?: SortOrder
    attempts?: SortOrder
    conflictResolution?: SortOrder
  }

  export type SyncLogSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EnumSyncOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationWithAggregatesFilter<$PrismaModel> | $Enums.SyncOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncOperationFilter<$PrismaModel>
    _max?: NestedEnumSyncOperationFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[]
    notIn?: $Enums.NotificationCategory[]
    not?: NestedEnumNotificationCategoryFilter<$PrismaModel> | $Enums.NotificationCategory
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[]
    notIn?: $Enums.NotificationPriority[]
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    recipientIds?: SortOrder
    globalNotification?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    readBy?: SortOrder
    expiresAt?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrder
    actionData?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    globalNotification?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    readBy?: SortOrder
    expiresAt?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    message?: SortOrder
    globalNotification?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    readBy?: SortOrder
    expiresAt?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[]
    notIn?: $Enums.NotificationCategory[]
    not?: NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationCategoryFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[]
    notIn?: $Enums.NotificationPriority[]
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TransactionCreateNestedManyWithoutStaffInput = {
    create?: XOR<TransactionCreateWithoutStaffInput, TransactionUncheckedCreateWithoutStaffInput> | TransactionCreateWithoutStaffInput[] | TransactionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStaffInput | TransactionCreateOrConnectWithoutStaffInput[]
    createMany?: TransactionCreateManyStaffInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EggCollectionCreateNestedManyWithoutStaffInput = {
    create?: XOR<EggCollectionCreateWithoutStaffInput, EggCollectionUncheckedCreateWithoutStaffInput> | EggCollectionCreateWithoutStaffInput[] | EggCollectionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutStaffInput | EggCollectionCreateOrConnectWithoutStaffInput[]
    createMany?: EggCollectionCreateManyStaffInputEnvelope
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
  }

  export type PaymentRecordCreateNestedManyWithoutStaffInput = {
    create?: XOR<PaymentRecordCreateWithoutStaffInput, PaymentRecordUncheckedCreateWithoutStaffInput> | PaymentRecordCreateWithoutStaffInput[] | PaymentRecordUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutStaffInput | PaymentRecordCreateOrConnectWithoutStaffInput[]
    createMany?: PaymentRecordCreateManyStaffInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type CollectionRouteCreateNestedManyWithoutStaffInput = {
    create?: XOR<CollectionRouteCreateWithoutStaffInput, CollectionRouteUncheckedCreateWithoutStaffInput> | CollectionRouteCreateWithoutStaffInput[] | CollectionRouteUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutStaffInput | CollectionRouteCreateOrConnectWithoutStaffInput[]
    createMany?: CollectionRouteCreateManyStaffInputEnvelope
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutStaffInput = {
    create?: XOR<PurchaseOrderCreateWithoutStaffInput, PurchaseOrderUncheckedCreateWithoutStaffInput> | PurchaseOrderCreateWithoutStaffInput[] | PurchaseOrderUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStaffInput | PurchaseOrderCreateOrConnectWithoutStaffInput[]
    createMany?: PurchaseOrderCreateManyStaffInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<TransactionCreateWithoutStaffInput, TransactionUncheckedCreateWithoutStaffInput> | TransactionCreateWithoutStaffInput[] | TransactionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStaffInput | TransactionCreateOrConnectWithoutStaffInput[]
    createMany?: TransactionCreateManyStaffInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EggCollectionUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<EggCollectionCreateWithoutStaffInput, EggCollectionUncheckedCreateWithoutStaffInput> | EggCollectionCreateWithoutStaffInput[] | EggCollectionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutStaffInput | EggCollectionCreateOrConnectWithoutStaffInput[]
    createMany?: EggCollectionCreateManyStaffInputEnvelope
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
  }

  export type PaymentRecordUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<PaymentRecordCreateWithoutStaffInput, PaymentRecordUncheckedCreateWithoutStaffInput> | PaymentRecordCreateWithoutStaffInput[] | PaymentRecordUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutStaffInput | PaymentRecordCreateOrConnectWithoutStaffInput[]
    createMany?: PaymentRecordCreateManyStaffInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type CollectionRouteUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<CollectionRouteCreateWithoutStaffInput, CollectionRouteUncheckedCreateWithoutStaffInput> | CollectionRouteCreateWithoutStaffInput[] | CollectionRouteUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutStaffInput | CollectionRouteCreateOrConnectWithoutStaffInput[]
    createMany?: CollectionRouteCreateManyStaffInputEnvelope
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<PurchaseOrderCreateWithoutStaffInput, PurchaseOrderUncheckedCreateWithoutStaffInput> | PurchaseOrderCreateWithoutStaffInput[] | PurchaseOrderUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStaffInput | PurchaseOrderCreateOrConnectWithoutStaffInput[]
    createMany?: PurchaseOrderCreateManyStaffInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type EnumStaffPositionFieldUpdateOperationsInput = {
    set?: $Enums.StaffPosition
  }

  export type EnumStaffDepartmentFieldUpdateOperationsInput = {
    set?: $Enums.StaffDepartment
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionUpdateManyWithoutStaffNestedInput = {
    create?: XOR<TransactionCreateWithoutStaffInput, TransactionUncheckedCreateWithoutStaffInput> | TransactionCreateWithoutStaffInput[] | TransactionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStaffInput | TransactionCreateOrConnectWithoutStaffInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutStaffInput | TransactionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: TransactionCreateManyStaffInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutStaffInput | TransactionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutStaffInput | TransactionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type EggCollectionUpdateManyWithoutStaffNestedInput = {
    create?: XOR<EggCollectionCreateWithoutStaffInput, EggCollectionUncheckedCreateWithoutStaffInput> | EggCollectionCreateWithoutStaffInput[] | EggCollectionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutStaffInput | EggCollectionCreateOrConnectWithoutStaffInput[]
    upsert?: EggCollectionUpsertWithWhereUniqueWithoutStaffInput | EggCollectionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: EggCollectionCreateManyStaffInputEnvelope
    set?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    disconnect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    delete?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    update?: EggCollectionUpdateWithWhereUniqueWithoutStaffInput | EggCollectionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: EggCollectionUpdateManyWithWhereWithoutStaffInput | EggCollectionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
  }

  export type PaymentRecordUpdateManyWithoutStaffNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutStaffInput, PaymentRecordUncheckedCreateWithoutStaffInput> | PaymentRecordCreateWithoutStaffInput[] | PaymentRecordUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutStaffInput | PaymentRecordCreateOrConnectWithoutStaffInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutStaffInput | PaymentRecordUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: PaymentRecordCreateManyStaffInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutStaffInput | PaymentRecordUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutStaffInput | PaymentRecordUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type CollectionRouteUpdateManyWithoutStaffNestedInput = {
    create?: XOR<CollectionRouteCreateWithoutStaffInput, CollectionRouteUncheckedCreateWithoutStaffInput> | CollectionRouteCreateWithoutStaffInput[] | CollectionRouteUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutStaffInput | CollectionRouteCreateOrConnectWithoutStaffInput[]
    upsert?: CollectionRouteUpsertWithWhereUniqueWithoutStaffInput | CollectionRouteUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: CollectionRouteCreateManyStaffInputEnvelope
    set?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    disconnect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    delete?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    update?: CollectionRouteUpdateWithWhereUniqueWithoutStaffInput | CollectionRouteUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: CollectionRouteUpdateManyWithWhereWithoutStaffInput | CollectionRouteUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: CollectionRouteScalarWhereInput | CollectionRouteScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutStaffNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutStaffInput, PurchaseOrderUncheckedCreateWithoutStaffInput> | PurchaseOrderCreateWithoutStaffInput[] | PurchaseOrderUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStaffInput | PurchaseOrderCreateOrConnectWithoutStaffInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutStaffInput | PurchaseOrderUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: PurchaseOrderCreateManyStaffInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutStaffInput | PurchaseOrderUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutStaffInput | PurchaseOrderUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<TransactionCreateWithoutStaffInput, TransactionUncheckedCreateWithoutStaffInput> | TransactionCreateWithoutStaffInput[] | TransactionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutStaffInput | TransactionCreateOrConnectWithoutStaffInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutStaffInput | TransactionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: TransactionCreateManyStaffInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutStaffInput | TransactionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutStaffInput | TransactionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type EggCollectionUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<EggCollectionCreateWithoutStaffInput, EggCollectionUncheckedCreateWithoutStaffInput> | EggCollectionCreateWithoutStaffInput[] | EggCollectionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutStaffInput | EggCollectionCreateOrConnectWithoutStaffInput[]
    upsert?: EggCollectionUpsertWithWhereUniqueWithoutStaffInput | EggCollectionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: EggCollectionCreateManyStaffInputEnvelope
    set?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    disconnect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    delete?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    update?: EggCollectionUpdateWithWhereUniqueWithoutStaffInput | EggCollectionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: EggCollectionUpdateManyWithWhereWithoutStaffInput | EggCollectionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
  }

  export type PaymentRecordUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutStaffInput, PaymentRecordUncheckedCreateWithoutStaffInput> | PaymentRecordCreateWithoutStaffInput[] | PaymentRecordUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutStaffInput | PaymentRecordCreateOrConnectWithoutStaffInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutStaffInput | PaymentRecordUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: PaymentRecordCreateManyStaffInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutStaffInput | PaymentRecordUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutStaffInput | PaymentRecordUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type CollectionRouteUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<CollectionRouteCreateWithoutStaffInput, CollectionRouteUncheckedCreateWithoutStaffInput> | CollectionRouteCreateWithoutStaffInput[] | CollectionRouteUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutStaffInput | CollectionRouteCreateOrConnectWithoutStaffInput[]
    upsert?: CollectionRouteUpsertWithWhereUniqueWithoutStaffInput | CollectionRouteUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: CollectionRouteCreateManyStaffInputEnvelope
    set?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    disconnect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    delete?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    update?: CollectionRouteUpdateWithWhereUniqueWithoutStaffInput | CollectionRouteUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: CollectionRouteUpdateManyWithWhereWithoutStaffInput | CollectionRouteUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: CollectionRouteScalarWhereInput | CollectionRouteScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutStaffInput, PurchaseOrderUncheckedCreateWithoutStaffInput> | PurchaseOrderCreateWithoutStaffInput[] | PurchaseOrderUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutStaffInput | PurchaseOrderCreateOrConnectWithoutStaffInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutStaffInput | PurchaseOrderUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: PurchaseOrderCreateManyStaffInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutStaffInput | PurchaseOrderUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutStaffInput | PurchaseOrderUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EggCollectionCreateNestedManyWithoutFarmerInput = {
    create?: XOR<EggCollectionCreateWithoutFarmerInput, EggCollectionUncheckedCreateWithoutFarmerInput> | EggCollectionCreateWithoutFarmerInput[] | EggCollectionUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutFarmerInput | EggCollectionCreateOrConnectWithoutFarmerInput[]
    createMany?: EggCollectionCreateManyFarmerInputEnvelope
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
  }

  export type PaymentRecordCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentRecordCreateWithoutCustomerInput, PaymentRecordUncheckedCreateWithoutCustomerInput> | PaymentRecordCreateWithoutCustomerInput[] | PaymentRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutCustomerInput | PaymentRecordCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentRecordCreateManyCustomerInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type CollectionRouteCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CollectionRouteCreateWithoutCustomersInput, CollectionRouteUncheckedCreateWithoutCustomersInput> | CollectionRouteCreateWithoutCustomersInput[] | CollectionRouteUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutCustomersInput | CollectionRouteCreateOrConnectWithoutCustomersInput[]
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EggCollectionUncheckedCreateNestedManyWithoutFarmerInput = {
    create?: XOR<EggCollectionCreateWithoutFarmerInput, EggCollectionUncheckedCreateWithoutFarmerInput> | EggCollectionCreateWithoutFarmerInput[] | EggCollectionUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutFarmerInput | EggCollectionCreateOrConnectWithoutFarmerInput[]
    createMany?: EggCollectionCreateManyFarmerInputEnvelope
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
  }

  export type PaymentRecordUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentRecordCreateWithoutCustomerInput, PaymentRecordUncheckedCreateWithoutCustomerInput> | PaymentRecordCreateWithoutCustomerInput[] | PaymentRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutCustomerInput | PaymentRecordCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentRecordCreateManyCustomerInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type CollectionRouteUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CollectionRouteCreateWithoutCustomersInput, CollectionRouteUncheckedCreateWithoutCustomersInput> | CollectionRouteCreateWithoutCustomersInput[] | CollectionRouteUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutCustomersInput | CollectionRouteCreateOrConnectWithoutCustomersInput[]
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type EnumCreditStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreditStatus
  }

  export type EnumCollectionScheduleFieldUpdateOperationsInput = {
    set?: $Enums.CollectionSchedule
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type EggCollectionUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<EggCollectionCreateWithoutFarmerInput, EggCollectionUncheckedCreateWithoutFarmerInput> | EggCollectionCreateWithoutFarmerInput[] | EggCollectionUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutFarmerInput | EggCollectionCreateOrConnectWithoutFarmerInput[]
    upsert?: EggCollectionUpsertWithWhereUniqueWithoutFarmerInput | EggCollectionUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: EggCollectionCreateManyFarmerInputEnvelope
    set?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    disconnect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    delete?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    update?: EggCollectionUpdateWithWhereUniqueWithoutFarmerInput | EggCollectionUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: EggCollectionUpdateManyWithWhereWithoutFarmerInput | EggCollectionUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
  }

  export type PaymentRecordUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutCustomerInput, PaymentRecordUncheckedCreateWithoutCustomerInput> | PaymentRecordCreateWithoutCustomerInput[] | PaymentRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutCustomerInput | PaymentRecordCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutCustomerInput | PaymentRecordUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentRecordCreateManyCustomerInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutCustomerInput | PaymentRecordUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutCustomerInput | PaymentRecordUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type CollectionRouteUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CollectionRouteCreateWithoutCustomersInput, CollectionRouteUncheckedCreateWithoutCustomersInput> | CollectionRouteCreateWithoutCustomersInput[] | CollectionRouteUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutCustomersInput | CollectionRouteCreateOrConnectWithoutCustomersInput[]
    upsert?: CollectionRouteUpsertWithWhereUniqueWithoutCustomersInput | CollectionRouteUpsertWithWhereUniqueWithoutCustomersInput[]
    set?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    disconnect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    delete?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    update?: CollectionRouteUpdateWithWhereUniqueWithoutCustomersInput | CollectionRouteUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CollectionRouteUpdateManyWithWhereWithoutCustomersInput | CollectionRouteUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CollectionRouteScalarWhereInput | CollectionRouteScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type EggCollectionUncheckedUpdateManyWithoutFarmerNestedInput = {
    create?: XOR<EggCollectionCreateWithoutFarmerInput, EggCollectionUncheckedCreateWithoutFarmerInput> | EggCollectionCreateWithoutFarmerInput[] | EggCollectionUncheckedCreateWithoutFarmerInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutFarmerInput | EggCollectionCreateOrConnectWithoutFarmerInput[]
    upsert?: EggCollectionUpsertWithWhereUniqueWithoutFarmerInput | EggCollectionUpsertWithWhereUniqueWithoutFarmerInput[]
    createMany?: EggCollectionCreateManyFarmerInputEnvelope
    set?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    disconnect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    delete?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    update?: EggCollectionUpdateWithWhereUniqueWithoutFarmerInput | EggCollectionUpdateWithWhereUniqueWithoutFarmerInput[]
    updateMany?: EggCollectionUpdateManyWithWhereWithoutFarmerInput | EggCollectionUpdateManyWithWhereWithoutFarmerInput[]
    deleteMany?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
  }

  export type PaymentRecordUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutCustomerInput, PaymentRecordUncheckedCreateWithoutCustomerInput> | PaymentRecordCreateWithoutCustomerInput[] | PaymentRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutCustomerInput | PaymentRecordCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutCustomerInput | PaymentRecordUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentRecordCreateManyCustomerInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutCustomerInput | PaymentRecordUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutCustomerInput | PaymentRecordUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type CollectionRouteUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CollectionRouteCreateWithoutCustomersInput, CollectionRouteUncheckedCreateWithoutCustomersInput> | CollectionRouteCreateWithoutCustomersInput[] | CollectionRouteUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutCustomersInput | CollectionRouteCreateOrConnectWithoutCustomersInput[]
    upsert?: CollectionRouteUpsertWithWhereUniqueWithoutCustomersInput | CollectionRouteUpsertWithWhereUniqueWithoutCustomersInput[]
    set?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    disconnect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    delete?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    connect?: CollectionRouteWhereUniqueInput | CollectionRouteWhereUniqueInput[]
    update?: CollectionRouteUpdateWithWhereUniqueWithoutCustomersInput | CollectionRouteUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CollectionRouteUpdateManyWithWhereWithoutCustomersInput | CollectionRouteUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CollectionRouteScalarWhereInput | CollectionRouteScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutPrimaryVendorInput = {
    create?: XOR<ProductCreateWithoutPrimaryVendorInput, ProductUncheckedCreateWithoutPrimaryVendorInput> | ProductCreateWithoutPrimaryVendorInput[] | ProductUncheckedCreateWithoutPrimaryVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPrimaryVendorInput | ProductCreateOrConnectWithoutPrimaryVendorInput[]
    createMany?: ProductCreateManyPrimaryVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PaymentRecordCreateNestedManyWithoutVendorInput = {
    create?: XOR<PaymentRecordCreateWithoutVendorInput, PaymentRecordUncheckedCreateWithoutVendorInput> | PaymentRecordCreateWithoutVendorInput[] | PaymentRecordUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutVendorInput | PaymentRecordCreateOrConnectWithoutVendorInput[]
    createMany?: PaymentRecordCreateManyVendorInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutVendorInput = {
    create?: XOR<TransactionCreateWithoutVendorInput, TransactionUncheckedCreateWithoutVendorInput> | TransactionCreateWithoutVendorInput[] | TransactionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVendorInput | TransactionCreateOrConnectWithoutVendorInput[]
    createMany?: TransactionCreateManyVendorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutPrimaryVendorInput = {
    create?: XOR<ProductCreateWithoutPrimaryVendorInput, ProductUncheckedCreateWithoutPrimaryVendorInput> | ProductCreateWithoutPrimaryVendorInput[] | ProductUncheckedCreateWithoutPrimaryVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPrimaryVendorInput | ProductCreateOrConnectWithoutPrimaryVendorInput[]
    createMany?: ProductCreateManyPrimaryVendorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PaymentRecordUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PaymentRecordCreateWithoutVendorInput, PaymentRecordUncheckedCreateWithoutVendorInput> | PaymentRecordCreateWithoutVendorInput[] | PaymentRecordUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutVendorInput | PaymentRecordCreateOrConnectWithoutVendorInput[]
    createMany?: PaymentRecordCreateManyVendorInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<TransactionCreateWithoutVendorInput, TransactionUncheckedCreateWithoutVendorInput> | TransactionCreateWithoutVendorInput[] | TransactionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVendorInput | TransactionCreateOrConnectWithoutVendorInput[]
    createMany?: TransactionCreateManyVendorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutPrimaryVendorNestedInput = {
    create?: XOR<ProductCreateWithoutPrimaryVendorInput, ProductUncheckedCreateWithoutPrimaryVendorInput> | ProductCreateWithoutPrimaryVendorInput[] | ProductUncheckedCreateWithoutPrimaryVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPrimaryVendorInput | ProductCreateOrConnectWithoutPrimaryVendorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPrimaryVendorInput | ProductUpsertWithWhereUniqueWithoutPrimaryVendorInput[]
    createMany?: ProductCreateManyPrimaryVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPrimaryVendorInput | ProductUpdateWithWhereUniqueWithoutPrimaryVendorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPrimaryVendorInput | ProductUpdateManyWithWhereWithoutPrimaryVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PaymentRecordUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutVendorInput, PaymentRecordUncheckedCreateWithoutVendorInput> | PaymentRecordCreateWithoutVendorInput[] | PaymentRecordUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutVendorInput | PaymentRecordCreateOrConnectWithoutVendorInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutVendorInput | PaymentRecordUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PaymentRecordCreateManyVendorInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutVendorInput | PaymentRecordUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutVendorInput | PaymentRecordUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutVendorNestedInput = {
    create?: XOR<TransactionCreateWithoutVendorInput, TransactionUncheckedCreateWithoutVendorInput> | TransactionCreateWithoutVendorInput[] | TransactionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVendorInput | TransactionCreateOrConnectWithoutVendorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVendorInput | TransactionUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: TransactionCreateManyVendorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVendorInput | TransactionUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVendorInput | TransactionUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutPrimaryVendorNestedInput = {
    create?: XOR<ProductCreateWithoutPrimaryVendorInput, ProductUncheckedCreateWithoutPrimaryVendorInput> | ProductCreateWithoutPrimaryVendorInput[] | ProductUncheckedCreateWithoutPrimaryVendorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPrimaryVendorInput | ProductCreateOrConnectWithoutPrimaryVendorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPrimaryVendorInput | ProductUpsertWithWhereUniqueWithoutPrimaryVendorInput[]
    createMany?: ProductCreateManyPrimaryVendorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPrimaryVendorInput | ProductUpdateWithWhereUniqueWithoutPrimaryVendorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPrimaryVendorInput | ProductUpdateManyWithWhereWithoutPrimaryVendorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PaymentRecordUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutVendorInput, PaymentRecordUncheckedCreateWithoutVendorInput> | PaymentRecordCreateWithoutVendorInput[] | PaymentRecordUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutVendorInput | PaymentRecordCreateOrConnectWithoutVendorInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutVendorInput | PaymentRecordUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PaymentRecordCreateManyVendorInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutVendorInput | PaymentRecordUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutVendorInput | PaymentRecordUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<TransactionCreateWithoutVendorInput, TransactionUncheckedCreateWithoutVendorInput> | TransactionCreateWithoutVendorInput[] | TransactionUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVendorInput | TransactionCreateOrConnectWithoutVendorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVendorInput | TransactionUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: TransactionCreateManyVendorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVendorInput | TransactionUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVendorInput | TransactionUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutProductsInput = {
    create?: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutProductsInput
    connect?: VendorWhereUniqueInput
  }

  export type TransactionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type TransactionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type VendorUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutProductsInput
    upsert?: VendorUpsertWithoutProductsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutProductsInput, VendorUpdateWithoutProductsInput>, VendorUncheckedUpdateWithoutProductsInput>
  }

  export type TransactionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutProductInput | TransactionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutProductInput | TransactionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutProductInput | TransactionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type TransactionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutProductInput | TransactionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutProductInput | TransactionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutProductInput | TransactionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutTransactionInput = {
    create?: XOR<VendorCreateWithoutTransactionInput, VendorUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: VendorCreateOrConnectWithoutTransactionInput
    connect?: VendorWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<StaffCreateWithoutTransactionsInput, StaffUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutTransactionsInput
    connect?: StaffWhereUniqueInput
  }

  export type TransactionItemCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type PaymentRecordCreateNestedManyWithoutTransactionInput = {
    create?: XOR<PaymentRecordCreateWithoutTransactionInput, PaymentRecordUncheckedCreateWithoutTransactionInput> | PaymentRecordCreateWithoutTransactionInput[] | PaymentRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutTransactionInput | PaymentRecordCreateOrConnectWithoutTransactionInput[]
    createMany?: PaymentRecordCreateManyTransactionInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type TransactionItemUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type PaymentRecordUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<PaymentRecordCreateWithoutTransactionInput, PaymentRecordUncheckedCreateWithoutTransactionInput> | PaymentRecordCreateWithoutTransactionInput[] | PaymentRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutTransactionInput | PaymentRecordCreateOrConnectWithoutTransactionInput[]
    createMany?: PaymentRecordCreateManyTransactionInputEnvelope
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type CustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type VendorUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<VendorCreateWithoutTransactionInput, VendorUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: VendorCreateOrConnectWithoutTransactionInput
    upsert?: VendorUpsertWithoutTransactionInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutTransactionInput, VendorUpdateWithoutTransactionInput>, VendorUncheckedUpdateWithoutTransactionInput>
  }

  export type StaffUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<StaffCreateWithoutTransactionsInput, StaffUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutTransactionsInput
    upsert?: StaffUpsertWithoutTransactionsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutTransactionsInput, StaffUpdateWithoutTransactionsInput>, StaffUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionItemUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutTransactionInput | TransactionItemUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutTransactionInput | TransactionItemUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutTransactionInput | TransactionItemUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type PaymentRecordUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutTransactionInput, PaymentRecordUncheckedCreateWithoutTransactionInput> | PaymentRecordCreateWithoutTransactionInput[] | PaymentRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutTransactionInput | PaymentRecordCreateOrConnectWithoutTransactionInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutTransactionInput | PaymentRecordUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: PaymentRecordCreateManyTransactionInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutTransactionInput | PaymentRecordUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutTransactionInput | PaymentRecordUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutTransactionInput | TransactionItemUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutTransactionInput | TransactionItemUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutTransactionInput | TransactionItemUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type PaymentRecordUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<PaymentRecordCreateWithoutTransactionInput, PaymentRecordUncheckedCreateWithoutTransactionInput> | PaymentRecordCreateWithoutTransactionInput[] | PaymentRecordUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: PaymentRecordCreateOrConnectWithoutTransactionInput | PaymentRecordCreateOrConnectWithoutTransactionInput[]
    upsert?: PaymentRecordUpsertWithWhereUniqueWithoutTransactionInput | PaymentRecordUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: PaymentRecordCreateManyTransactionInputEnvelope
    set?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    disconnect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    delete?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    connect?: PaymentRecordWhereUniqueInput | PaymentRecordWhereUniqueInput[]
    update?: PaymentRecordUpdateWithWhereUniqueWithoutTransactionInput | PaymentRecordUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: PaymentRecordUpdateManyWithWhereWithoutTransactionInput | PaymentRecordUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutItemsInput
    connect?: TransactionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransactionItemsInput = {
    create?: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutItemsInput
    upsert?: TransactionUpsertWithoutItemsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutItemsInput, TransactionUpdateWithoutItemsInput>, TransactionUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutTransactionItemsNestedInput = {
    create?: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionItemsInput
    upsert?: ProductUpsertWithoutTransactionItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransactionItemsInput, ProductUpdateWithoutTransactionItemsInput>, ProductUncheckedUpdateWithoutTransactionItemsInput>
  }

  export type CustomerCreateNestedOneWithoutEggCollectionsInput = {
    create?: XOR<CustomerCreateWithoutEggCollectionsInput, CustomerUncheckedCreateWithoutEggCollectionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutEggCollectionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CollectionRouteCreateNestedOneWithoutEggCollectionsInput = {
    create?: XOR<CollectionRouteCreateWithoutEggCollectionsInput, CollectionRouteUncheckedCreateWithoutEggCollectionsInput>
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutEggCollectionsInput
    connect?: CollectionRouteWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutEggCollectionsInput = {
    create?: XOR<StaffCreateWithoutEggCollectionsInput, StaffUncheckedCreateWithoutEggCollectionsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutEggCollectionsInput
    connect?: StaffWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutEggCollectionsNestedInput = {
    create?: XOR<CustomerCreateWithoutEggCollectionsInput, CustomerUncheckedCreateWithoutEggCollectionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutEggCollectionsInput
    upsert?: CustomerUpsertWithoutEggCollectionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutEggCollectionsInput, CustomerUpdateWithoutEggCollectionsInput>, CustomerUncheckedUpdateWithoutEggCollectionsInput>
  }

  export type CollectionRouteUpdateOneWithoutEggCollectionsNestedInput = {
    create?: XOR<CollectionRouteCreateWithoutEggCollectionsInput, CollectionRouteUncheckedCreateWithoutEggCollectionsInput>
    connectOrCreate?: CollectionRouteCreateOrConnectWithoutEggCollectionsInput
    upsert?: CollectionRouteUpsertWithoutEggCollectionsInput
    disconnect?: CollectionRouteWhereInput | boolean
    delete?: CollectionRouteWhereInput | boolean
    connect?: CollectionRouteWhereUniqueInput
    update?: XOR<XOR<CollectionRouteUpdateToOneWithWhereWithoutEggCollectionsInput, CollectionRouteUpdateWithoutEggCollectionsInput>, CollectionRouteUncheckedUpdateWithoutEggCollectionsInput>
  }

  export type StaffUpdateOneRequiredWithoutEggCollectionsNestedInput = {
    create?: XOR<StaffCreateWithoutEggCollectionsInput, StaffUncheckedCreateWithoutEggCollectionsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutEggCollectionsInput
    upsert?: StaffUpsertWithoutEggCollectionsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutEggCollectionsInput, StaffUpdateWithoutEggCollectionsInput>, StaffUncheckedUpdateWithoutEggCollectionsInput>
  }

  export type StaffCreateNestedOneWithoutCollectionRoutesInput = {
    create?: XOR<StaffCreateWithoutCollectionRoutesInput, StaffUncheckedCreateWithoutCollectionRoutesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutCollectionRoutesInput
    connect?: StaffWhereUniqueInput
  }

  export type CustomerCreateNestedManyWithoutRoutesInput = {
    create?: XOR<CustomerCreateWithoutRoutesInput, CustomerUncheckedCreateWithoutRoutesInput> | CustomerCreateWithoutRoutesInput[] | CustomerUncheckedCreateWithoutRoutesInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutRoutesInput | CustomerCreateOrConnectWithoutRoutesInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type EggCollectionCreateNestedManyWithoutRouteInput = {
    create?: XOR<EggCollectionCreateWithoutRouteInput, EggCollectionUncheckedCreateWithoutRouteInput> | EggCollectionCreateWithoutRouteInput[] | EggCollectionUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutRouteInput | EggCollectionCreateOrConnectWithoutRouteInput[]
    createMany?: EggCollectionCreateManyRouteInputEnvelope
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutRoutesInput = {
    create?: XOR<CustomerCreateWithoutRoutesInput, CustomerUncheckedCreateWithoutRoutesInput> | CustomerCreateWithoutRoutesInput[] | CustomerUncheckedCreateWithoutRoutesInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutRoutesInput | CustomerCreateOrConnectWithoutRoutesInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type EggCollectionUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<EggCollectionCreateWithoutRouteInput, EggCollectionUncheckedCreateWithoutRouteInput> | EggCollectionCreateWithoutRouteInput[] | EggCollectionUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutRouteInput | EggCollectionCreateOrConnectWithoutRouteInput[]
    createMany?: EggCollectionCreateManyRouteInputEnvelope
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
  }

  export type StaffUpdateOneWithoutCollectionRoutesNestedInput = {
    create?: XOR<StaffCreateWithoutCollectionRoutesInput, StaffUncheckedCreateWithoutCollectionRoutesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutCollectionRoutesInput
    upsert?: StaffUpsertWithoutCollectionRoutesInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutCollectionRoutesInput, StaffUpdateWithoutCollectionRoutesInput>, StaffUncheckedUpdateWithoutCollectionRoutesInput>
  }

  export type CustomerUpdateManyWithoutRoutesNestedInput = {
    create?: XOR<CustomerCreateWithoutRoutesInput, CustomerUncheckedCreateWithoutRoutesInput> | CustomerCreateWithoutRoutesInput[] | CustomerUncheckedCreateWithoutRoutesInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutRoutesInput | CustomerCreateOrConnectWithoutRoutesInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutRoutesInput | CustomerUpsertWithWhereUniqueWithoutRoutesInput[]
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutRoutesInput | CustomerUpdateWithWhereUniqueWithoutRoutesInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutRoutesInput | CustomerUpdateManyWithWhereWithoutRoutesInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type EggCollectionUpdateManyWithoutRouteNestedInput = {
    create?: XOR<EggCollectionCreateWithoutRouteInput, EggCollectionUncheckedCreateWithoutRouteInput> | EggCollectionCreateWithoutRouteInput[] | EggCollectionUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutRouteInput | EggCollectionCreateOrConnectWithoutRouteInput[]
    upsert?: EggCollectionUpsertWithWhereUniqueWithoutRouteInput | EggCollectionUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: EggCollectionCreateManyRouteInputEnvelope
    set?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    disconnect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    delete?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    update?: EggCollectionUpdateWithWhereUniqueWithoutRouteInput | EggCollectionUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: EggCollectionUpdateManyWithWhereWithoutRouteInput | EggCollectionUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutRoutesNestedInput = {
    create?: XOR<CustomerCreateWithoutRoutesInput, CustomerUncheckedCreateWithoutRoutesInput> | CustomerCreateWithoutRoutesInput[] | CustomerUncheckedCreateWithoutRoutesInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutRoutesInput | CustomerCreateOrConnectWithoutRoutesInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutRoutesInput | CustomerUpsertWithWhereUniqueWithoutRoutesInput[]
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutRoutesInput | CustomerUpdateWithWhereUniqueWithoutRoutesInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutRoutesInput | CustomerUpdateManyWithWhereWithoutRoutesInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type EggCollectionUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<EggCollectionCreateWithoutRouteInput, EggCollectionUncheckedCreateWithoutRouteInput> | EggCollectionCreateWithoutRouteInput[] | EggCollectionUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: EggCollectionCreateOrConnectWithoutRouteInput | EggCollectionCreateOrConnectWithoutRouteInput[]
    upsert?: EggCollectionUpsertWithWhereUniqueWithoutRouteInput | EggCollectionUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: EggCollectionCreateManyRouteInputEnvelope
    set?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    disconnect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    delete?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    connect?: EggCollectionWhereUniqueInput | EggCollectionWhereUniqueInput[]
    update?: EggCollectionUpdateWithWhereUniqueWithoutRouteInput | EggCollectionUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: EggCollectionUpdateManyWithWhereWithoutRouteInput | EggCollectionUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrdersInput
    connect?: VendorWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<StaffCreateWithoutPurchaseOrderInput, StaffUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: StaffCreateOrConnectWithoutPurchaseOrderInput
    connect?: StaffWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type EnumPurchaseOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseOrderStatus
  }

  export type VendorUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: VendorUpsertWithoutPurchaseOrdersInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchaseOrdersInput, VendorUpdateWithoutPurchaseOrdersInput>, VendorUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type StaffUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<StaffCreateWithoutPurchaseOrderInput, StaffUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: StaffCreateOrConnectWithoutPurchaseOrderInput
    upsert?: StaffUpsertWithoutPurchaseOrderInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutPurchaseOrderInput, StaffUpdateWithoutPurchaseOrderInput>, StaffUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ProductUpsertWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ProductUpdateWithoutPurchaseOrderItemsInput>, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type CustomerCreateNestedOneWithoutPaymentRecordsInput = {
    create?: XOR<CustomerCreateWithoutPaymentRecordsInput, CustomerUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentRecordsInput
    connect?: CustomerWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPaymentRecordsInput = {
    create?: XOR<VendorCreateWithoutPaymentRecordsInput, VendorUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPaymentRecordsInput
    connect?: VendorWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPaymentRecordsInput = {
    create?: XOR<TransactionCreateWithoutPaymentRecordsInput, TransactionUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentRecordsInput
    connect?: TransactionWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutPaymentRecordsInput = {
    create?: XOR<StaffCreateWithoutPaymentRecordsInput, StaffUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutPaymentRecordsInput
    connect?: StaffWhereUniqueInput
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type CustomerUpdateOneWithoutPaymentRecordsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentRecordsInput, CustomerUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentRecordsInput
    upsert?: CustomerUpsertWithoutPaymentRecordsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentRecordsInput, CustomerUpdateWithoutPaymentRecordsInput>, CustomerUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type VendorUpdateOneWithoutPaymentRecordsNestedInput = {
    create?: XOR<VendorCreateWithoutPaymentRecordsInput, VendorUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPaymentRecordsInput
    upsert?: VendorUpsertWithoutPaymentRecordsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPaymentRecordsInput, VendorUpdateWithoutPaymentRecordsInput>, VendorUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type TransactionUpdateOneWithoutPaymentRecordsNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentRecordsInput, TransactionUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentRecordsInput
    upsert?: TransactionUpsertWithoutPaymentRecordsInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentRecordsInput, TransactionUpdateWithoutPaymentRecordsInput>, TransactionUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type StaffUpdateOneRequiredWithoutPaymentRecordsNestedInput = {
    create?: XOR<StaffCreateWithoutPaymentRecordsInput, StaffUncheckedCreateWithoutPaymentRecordsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutPaymentRecordsInput
    upsert?: StaffUpsertWithoutPaymentRecordsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutPaymentRecordsInput, StaffUpdateWithoutPaymentRecordsInput>, StaffUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type EnumSettingTypeFieldUpdateOperationsInput = {
    set?: $Enums.SettingType
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type EnumSyncOperationFieldUpdateOperationsInput = {
    set?: $Enums.SyncOperation
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NotificationCategory
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStaffPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffPosition | EnumStaffPositionFieldRefInput<$PrismaModel>
    in?: $Enums.StaffPosition[]
    notIn?: $Enums.StaffPosition[]
    not?: NestedEnumStaffPositionFilter<$PrismaModel> | $Enums.StaffPosition
  }

  export type NestedEnumStaffDepartmentFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffDepartment | EnumStaffDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.StaffDepartment[]
    notIn?: $Enums.StaffDepartment[]
    not?: NestedEnumStaffDepartmentFilter<$PrismaModel> | $Enums.StaffDepartment
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStaffPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffPosition | EnumStaffPositionFieldRefInput<$PrismaModel>
    in?: $Enums.StaffPosition[]
    notIn?: $Enums.StaffPosition[]
    not?: NestedEnumStaffPositionWithAggregatesFilter<$PrismaModel> | $Enums.StaffPosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffPositionFilter<$PrismaModel>
    _max?: NestedEnumStaffPositionFilter<$PrismaModel>
  }

  export type NestedEnumStaffDepartmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffDepartment | EnumStaffDepartmentFieldRefInput<$PrismaModel>
    in?: $Enums.StaffDepartment[]
    notIn?: $Enums.StaffDepartment[]
    not?: NestedEnumStaffDepartmentWithAggregatesFilter<$PrismaModel> | $Enums.StaffDepartment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffDepartmentFilter<$PrismaModel>
    _max?: NestedEnumStaffDepartmentFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedEnumCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusFilter<$PrismaModel> | $Enums.CreditStatus
  }

  export type NestedEnumCollectionScheduleFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionSchedule | EnumCollectionScheduleFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionSchedule[]
    notIn?: $Enums.CollectionSchedule[]
    not?: NestedEnumCollectionScheduleFilter<$PrismaModel> | $Enums.CollectionSchedule
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[]
    notIn?: $Enums.CreditStatus[]
    not?: NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCollectionScheduleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionSchedule | EnumCollectionScheduleFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionSchedule[]
    notIn?: $Enums.CollectionSchedule[]
    not?: NestedEnumCollectionScheduleWithAggregatesFilter<$PrismaModel> | $Enums.CollectionSchedule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionScheduleFilter<$PrismaModel>
    _max?: NestedEnumCollectionScheduleFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[]
    notIn?: $Enums.TransactionStatus[]
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[]
    notIn?: $Enums.PurchaseOrderStatus[]
    not?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
  }

  export type NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[]
    notIn?: $Enums.PurchaseOrderStatus[]
    not?: NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[]
    notIn?: $Enums.PaymentType[]
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[]
    notIn?: $Enums.PaymentType[]
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumSettingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeFilter<$PrismaModel> | $Enums.SettingType
  }

  export type NestedEnumSettingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeWithAggregatesFilter<$PrismaModel> | $Enums.SettingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSettingTypeFilter<$PrismaModel>
    _max?: NestedEnumSettingTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumSyncOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationFilter<$PrismaModel> | $Enums.SyncOperation
  }

  export type NestedEnumSyncOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationWithAggregatesFilter<$PrismaModel> | $Enums.SyncOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncOperationFilter<$PrismaModel>
    _max?: NestedEnumSyncOperationFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[]
    notIn?: $Enums.NotificationCategory[]
    not?: NestedEnumNotificationCategoryFilter<$PrismaModel> | $Enums.NotificationCategory
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[]
    notIn?: $Enums.NotificationPriority[]
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[]
    notIn?: $Enums.NotificationCategory[]
    not?: NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[]
    notIn?: $Enums.NotificationPriority[]
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type TransactionCreateWithoutStaffInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    vendor?: VendorCreateNestedOneWithoutTransactionInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutStaffInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutStaffInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutStaffInput, TransactionUncheckedCreateWithoutStaffInput>
  }

  export type TransactionCreateManyStaffInputEnvelope = {
    data: TransactionCreateManyStaffInput | TransactionCreateManyStaffInput[]
  }

  export type EggCollectionCreateWithoutStaffInput = {
    id?: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    farmer: CustomerCreateNestedOneWithoutEggCollectionsInput
    route?: CollectionRouteCreateNestedOneWithoutEggCollectionsInput
  }

  export type EggCollectionUncheckedCreateWithoutStaffInput = {
    id?: string
    farmerId: string
    routeId?: string | null
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionCreateOrConnectWithoutStaffInput = {
    where: EggCollectionWhereUniqueInput
    create: XOR<EggCollectionCreateWithoutStaffInput, EggCollectionUncheckedCreateWithoutStaffInput>
  }

  export type EggCollectionCreateManyStaffInputEnvelope = {
    data: EggCollectionCreateManyStaffInput | EggCollectionCreateManyStaffInput[]
  }

  export type PaymentRecordCreateWithoutStaffInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPaymentRecordsInput
    vendor?: VendorCreateNestedOneWithoutPaymentRecordsInput
    transaction?: TransactionCreateNestedOneWithoutPaymentRecordsInput
  }

  export type PaymentRecordUncheckedCreateWithoutStaffInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    vendorId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateOrConnectWithoutStaffInput = {
    where: PaymentRecordWhereUniqueInput
    create: XOR<PaymentRecordCreateWithoutStaffInput, PaymentRecordUncheckedCreateWithoutStaffInput>
  }

  export type PaymentRecordCreateManyStaffInputEnvelope = {
    data: PaymentRecordCreateManyStaffInput | PaymentRecordCreateManyStaffInput[]
  }

  export type CollectionRouteCreateWithoutStaffInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutRoutesInput
    eggCollections?: EggCollectionCreateNestedManyWithoutRouteInput
  }

  export type CollectionRouteUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutRoutesInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutRouteInput
  }

  export type CollectionRouteCreateOrConnectWithoutStaffInput = {
    where: CollectionRouteWhereUniqueInput
    create: XOR<CollectionRouteCreateWithoutStaffInput, CollectionRouteUncheckedCreateWithoutStaffInput>
  }

  export type CollectionRouteCreateManyStaffInputEnvelope = {
    data: CollectionRouteCreateManyStaffInput | CollectionRouteCreateManyStaffInput[]
  }

  export type PurchaseOrderCreateWithoutStaffInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutStaffInput = {
    id?: string
    orderNumber: string
    vendorId: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutStaffInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutStaffInput, PurchaseOrderUncheckedCreateWithoutStaffInput>
  }

  export type PurchaseOrderCreateManyStaffInputEnvelope = {
    data: PurchaseOrderCreateManyStaffInput | PurchaseOrderCreateManyStaffInput[]
  }

  export type TransactionUpsertWithWhereUniqueWithoutStaffInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutStaffInput, TransactionUncheckedUpdateWithoutStaffInput>
    create: XOR<TransactionCreateWithoutStaffInput, TransactionUncheckedCreateWithoutStaffInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutStaffInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutStaffInput, TransactionUncheckedUpdateWithoutStaffInput>
  }

  export type TransactionUpdateManyWithWhereWithoutStaffInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutStaffInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    receiptNumber?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    customerId?: StringNullableFilter<"Transaction"> | string | null
    vendorId?: StringNullableFilter<"Transaction"> | string | null
    subtotal?: FloatFilter<"Transaction"> | number
    tax?: FloatFilter<"Transaction"> | number
    discount?: FloatFilter<"Transaction"> | number
    total?: FloatFilter<"Transaction"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    paidAmount?: FloatFilter<"Transaction"> | number
    balanceAmount?: FloatFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeFilter<"Transaction"> | Date | string
    dueDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    staffId?: StringFilter<"Transaction"> | string
    notes?: StringNullableFilter<"Transaction"> | string | null
    synced?: BoolFilter<"Transaction"> | boolean
    cloudId?: StringNullableFilter<"Transaction"> | string | null
    syncError?: StringNullableFilter<"Transaction"> | string | null
    lastSync?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type EggCollectionUpsertWithWhereUniqueWithoutStaffInput = {
    where: EggCollectionWhereUniqueInput
    update: XOR<EggCollectionUpdateWithoutStaffInput, EggCollectionUncheckedUpdateWithoutStaffInput>
    create: XOR<EggCollectionCreateWithoutStaffInput, EggCollectionUncheckedCreateWithoutStaffInput>
  }

  export type EggCollectionUpdateWithWhereUniqueWithoutStaffInput = {
    where: EggCollectionWhereUniqueInput
    data: XOR<EggCollectionUpdateWithoutStaffInput, EggCollectionUncheckedUpdateWithoutStaffInput>
  }

  export type EggCollectionUpdateManyWithWhereWithoutStaffInput = {
    where: EggCollectionScalarWhereInput
    data: XOR<EggCollectionUpdateManyMutationInput, EggCollectionUncheckedUpdateManyWithoutStaffInput>
  }

  export type EggCollectionScalarWhereInput = {
    AND?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
    OR?: EggCollectionScalarWhereInput[]
    NOT?: EggCollectionScalarWhereInput | EggCollectionScalarWhereInput[]
    id?: StringFilter<"EggCollection"> | string
    farmerId?: StringFilter<"EggCollection"> | string
    routeId?: StringNullableFilter<"EggCollection"> | string | null
    staffId?: StringFilter<"EggCollection"> | string
    collectionDate?: DateTimeFilter<"EggCollection"> | Date | string
    henEggsSmall?: IntFilter<"EggCollection"> | number
    henEggsMedium?: IntFilter<"EggCollection"> | number
    henEggsLarge?: IntFilter<"EggCollection"> | number
    henEggsExtraLarge?: IntFilter<"EggCollection"> | number
    henEggsDamaged?: IntFilter<"EggCollection"> | number
    totalHenEggs?: IntFilter<"EggCollection"> | number
    duckEggsSmall?: IntFilter<"EggCollection"> | number
    duckEggsMedium?: IntFilter<"EggCollection"> | number
    duckEggsLarge?: IntFilter<"EggCollection"> | number
    duckEggsDamaged?: IntFilter<"EggCollection"> | number
    totalDuckEggs?: IntFilter<"EggCollection"> | number
    henEggPrice?: FloatFilter<"EggCollection"> | number
    duckEggPrice?: FloatFilter<"EggCollection"> | number
    totalValue?: FloatFilter<"EggCollection"> | number
    qualityScore?: FloatNullableFilter<"EggCollection"> | number | null
    qualityNotes?: StringNullableFilter<"EggCollection"> | string | null
    paid?: BoolFilter<"EggCollection"> | boolean
    paymentDate?: DateTimeNullableFilter<"EggCollection"> | Date | string | null
    synced?: BoolFilter<"EggCollection"> | boolean
    cloudId?: StringNullableFilter<"EggCollection"> | string | null
    syncError?: StringNullableFilter<"EggCollection"> | string | null
    lastSync?: DateTimeNullableFilter<"EggCollection"> | Date | string | null
    createdAt?: DateTimeFilter<"EggCollection"> | Date | string
    updatedAt?: DateTimeFilter<"EggCollection"> | Date | string
  }

  export type PaymentRecordUpsertWithWhereUniqueWithoutStaffInput = {
    where: PaymentRecordWhereUniqueInput
    update: XOR<PaymentRecordUpdateWithoutStaffInput, PaymentRecordUncheckedUpdateWithoutStaffInput>
    create: XOR<PaymentRecordCreateWithoutStaffInput, PaymentRecordUncheckedCreateWithoutStaffInput>
  }

  export type PaymentRecordUpdateWithWhereUniqueWithoutStaffInput = {
    where: PaymentRecordWhereUniqueInput
    data: XOR<PaymentRecordUpdateWithoutStaffInput, PaymentRecordUncheckedUpdateWithoutStaffInput>
  }

  export type PaymentRecordUpdateManyWithWhereWithoutStaffInput = {
    where: PaymentRecordScalarWhereInput
    data: XOR<PaymentRecordUpdateManyMutationInput, PaymentRecordUncheckedUpdateManyWithoutStaffInput>
  }

  export type PaymentRecordScalarWhereInput = {
    AND?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
    OR?: PaymentRecordScalarWhereInput[]
    NOT?: PaymentRecordScalarWhereInput | PaymentRecordScalarWhereInput[]
    id?: StringFilter<"PaymentRecord"> | string
    type?: EnumPaymentTypeFilter<"PaymentRecord"> | $Enums.PaymentType
    amount?: FloatFilter<"PaymentRecord"> | number
    customerId?: StringNullableFilter<"PaymentRecord"> | string | null
    vendorId?: StringNullableFilter<"PaymentRecord"> | string | null
    transactionId?: StringNullableFilter<"PaymentRecord"> | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PaymentRecord"> | $Enums.PaymentMethod
    paymentDate?: DateTimeFilter<"PaymentRecord"> | Date | string
    dueDate?: DateTimeNullableFilter<"PaymentRecord"> | Date | string | null
    referenceNumber?: StringNullableFilter<"PaymentRecord"> | string | null
    checkNumber?: StringNullableFilter<"PaymentRecord"> | string | null
    processedBy?: StringFilter<"PaymentRecord"> | string
    notes?: StringNullableFilter<"PaymentRecord"> | string | null
    synced?: BoolFilter<"PaymentRecord"> | boolean
    createdAt?: DateTimeFilter<"PaymentRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRecord"> | Date | string
  }

  export type CollectionRouteUpsertWithWhereUniqueWithoutStaffInput = {
    where: CollectionRouteWhereUniqueInput
    update: XOR<CollectionRouteUpdateWithoutStaffInput, CollectionRouteUncheckedUpdateWithoutStaffInput>
    create: XOR<CollectionRouteCreateWithoutStaffInput, CollectionRouteUncheckedCreateWithoutStaffInput>
  }

  export type CollectionRouteUpdateWithWhereUniqueWithoutStaffInput = {
    where: CollectionRouteWhereUniqueInput
    data: XOR<CollectionRouteUpdateWithoutStaffInput, CollectionRouteUncheckedUpdateWithoutStaffInput>
  }

  export type CollectionRouteUpdateManyWithWhereWithoutStaffInput = {
    where: CollectionRouteScalarWhereInput
    data: XOR<CollectionRouteUpdateManyMutationInput, CollectionRouteUncheckedUpdateManyWithoutStaffInput>
  }

  export type CollectionRouteScalarWhereInput = {
    AND?: CollectionRouteScalarWhereInput | CollectionRouteScalarWhereInput[]
    OR?: CollectionRouteScalarWhereInput[]
    NOT?: CollectionRouteScalarWhereInput | CollectionRouteScalarWhereInput[]
    id?: StringFilter<"CollectionRoute"> | string
    name?: StringFilter<"CollectionRoute"> | string
    description?: StringNullableFilter<"CollectionRoute"> | string | null
    estimatedTime?: IntFilter<"CollectionRoute"> | number
    estimatedDistance?: FloatFilter<"CollectionRoute"> | number
    schedule?: EnumCollectionScheduleFilter<"CollectionRoute"> | $Enums.CollectionSchedule
    staffId?: StringNullableFilter<"CollectionRoute"> | string | null
    averageTime?: IntNullableFilter<"CollectionRoute"> | number | null
    onTimePercentage?: FloatNullableFilter<"CollectionRoute"> | number | null
    totalCollections?: IntFilter<"CollectionRoute"> | number
    active?: BoolFilter<"CollectionRoute"> | boolean
    createdAt?: DateTimeFilter<"CollectionRoute"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionRoute"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutStaffInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutStaffInput, PurchaseOrderUncheckedUpdateWithoutStaffInput>
    create: XOR<PurchaseOrderCreateWithoutStaffInput, PurchaseOrderUncheckedCreateWithoutStaffInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutStaffInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutStaffInput, PurchaseOrderUncheckedUpdateWithoutStaffInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutStaffInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutStaffInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    vendorId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    subtotal?: FloatFilter<"PurchaseOrder"> | number
    tax?: FloatFilter<"PurchaseOrder"> | number
    shipping?: FloatFilter<"PurchaseOrder"> | number
    total?: FloatFilter<"PurchaseOrder"> | number
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    orderedBy?: StringFilter<"PurchaseOrder"> | string
    receivedBy?: StringNullableFilter<"PurchaseOrder"> | string | null
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    synced?: BoolFilter<"PurchaseOrder"> | boolean
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type TransactionCreateWithoutCustomerInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutTransactionInput
    staff: StaffCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
  }

  export type EggCollectionCreateWithoutFarmerInput = {
    id?: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    route?: CollectionRouteCreateNestedOneWithoutEggCollectionsInput
    staff: StaffCreateNestedOneWithoutEggCollectionsInput
  }

  export type EggCollectionUncheckedCreateWithoutFarmerInput = {
    id?: string
    routeId?: string | null
    staffId: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionCreateOrConnectWithoutFarmerInput = {
    where: EggCollectionWhereUniqueInput
    create: XOR<EggCollectionCreateWithoutFarmerInput, EggCollectionUncheckedCreateWithoutFarmerInput>
  }

  export type EggCollectionCreateManyFarmerInputEnvelope = {
    data: EggCollectionCreateManyFarmerInput | EggCollectionCreateManyFarmerInput[]
  }

  export type PaymentRecordCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor?: VendorCreateNestedOneWithoutPaymentRecordsInput
    transaction?: TransactionCreateNestedOneWithoutPaymentRecordsInput
    staff: StaffCreateNestedOneWithoutPaymentRecordsInput
  }

  export type PaymentRecordUncheckedCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    vendorId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateOrConnectWithoutCustomerInput = {
    where: PaymentRecordWhereUniqueInput
    create: XOR<PaymentRecordCreateWithoutCustomerInput, PaymentRecordUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentRecordCreateManyCustomerInputEnvelope = {
    data: PaymentRecordCreateManyCustomerInput | PaymentRecordCreateManyCustomerInput[]
  }

  export type CollectionRouteCreateWithoutCustomersInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutCollectionRoutesInput
    eggCollections?: EggCollectionCreateNestedManyWithoutRouteInput
  }

  export type CollectionRouteUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    staffId?: string | null
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutRouteInput
  }

  export type CollectionRouteCreateOrConnectWithoutCustomersInput = {
    where: CollectionRouteWhereUniqueInput
    create: XOR<CollectionRouteCreateWithoutCustomersInput, CollectionRouteUncheckedCreateWithoutCustomersInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type EggCollectionUpsertWithWhereUniqueWithoutFarmerInput = {
    where: EggCollectionWhereUniqueInput
    update: XOR<EggCollectionUpdateWithoutFarmerInput, EggCollectionUncheckedUpdateWithoutFarmerInput>
    create: XOR<EggCollectionCreateWithoutFarmerInput, EggCollectionUncheckedCreateWithoutFarmerInput>
  }

  export type EggCollectionUpdateWithWhereUniqueWithoutFarmerInput = {
    where: EggCollectionWhereUniqueInput
    data: XOR<EggCollectionUpdateWithoutFarmerInput, EggCollectionUncheckedUpdateWithoutFarmerInput>
  }

  export type EggCollectionUpdateManyWithWhereWithoutFarmerInput = {
    where: EggCollectionScalarWhereInput
    data: XOR<EggCollectionUpdateManyMutationInput, EggCollectionUncheckedUpdateManyWithoutFarmerInput>
  }

  export type PaymentRecordUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentRecordWhereUniqueInput
    update: XOR<PaymentRecordUpdateWithoutCustomerInput, PaymentRecordUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentRecordCreateWithoutCustomerInput, PaymentRecordUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentRecordUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentRecordWhereUniqueInput
    data: XOR<PaymentRecordUpdateWithoutCustomerInput, PaymentRecordUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentRecordUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentRecordScalarWhereInput
    data: XOR<PaymentRecordUpdateManyMutationInput, PaymentRecordUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CollectionRouteUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CollectionRouteWhereUniqueInput
    update: XOR<CollectionRouteUpdateWithoutCustomersInput, CollectionRouteUncheckedUpdateWithoutCustomersInput>
    create: XOR<CollectionRouteCreateWithoutCustomersInput, CollectionRouteUncheckedCreateWithoutCustomersInput>
  }

  export type CollectionRouteUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CollectionRouteWhereUniqueInput
    data: XOR<CollectionRouteUpdateWithoutCustomersInput, CollectionRouteUncheckedUpdateWithoutCustomersInput>
  }

  export type CollectionRouteUpdateManyWithWhereWithoutCustomersInput = {
    where: CollectionRouteScalarWhereInput
    data: XOR<CollectionRouteUpdateManyMutationInput, CollectionRouteUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ProductCreateWithoutPrimaryVendorInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPrimaryVendorInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPrimaryVendorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPrimaryVendorInput, ProductUncheckedCreateWithoutPrimaryVendorInput>
  }

  export type ProductCreateManyPrimaryVendorInputEnvelope = {
    data: ProductCreateManyPrimaryVendorInput | ProductCreateManyPrimaryVendorInput[]
  }

  export type PurchaseOrderCreateWithoutVendorInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutPurchaseOrderInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutVendorInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    orderedBy: string
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderCreateManyVendorInputEnvelope = {
    data: PurchaseOrderCreateManyVendorInput | PurchaseOrderCreateManyVendorInput[]
  }

  export type PaymentRecordCreateWithoutVendorInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPaymentRecordsInput
    transaction?: TransactionCreateNestedOneWithoutPaymentRecordsInput
    staff: StaffCreateNestedOneWithoutPaymentRecordsInput
  }

  export type PaymentRecordUncheckedCreateWithoutVendorInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateOrConnectWithoutVendorInput = {
    where: PaymentRecordWhereUniqueInput
    create: XOR<PaymentRecordCreateWithoutVendorInput, PaymentRecordUncheckedCreateWithoutVendorInput>
  }

  export type PaymentRecordCreateManyVendorInputEnvelope = {
    data: PaymentRecordCreateManyVendorInput | PaymentRecordCreateManyVendorInput[]
  }

  export type TransactionCreateWithoutVendorInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    staff: StaffCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutVendorInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutVendorInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVendorInput, TransactionUncheckedCreateWithoutVendorInput>
  }

  export type TransactionCreateManyVendorInputEnvelope = {
    data: TransactionCreateManyVendorInput | TransactionCreateManyVendorInput[]
  }

  export type ProductUpsertWithWhereUniqueWithoutPrimaryVendorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPrimaryVendorInput, ProductUncheckedUpdateWithoutPrimaryVendorInput>
    create: XOR<ProductCreateWithoutPrimaryVendorInput, ProductUncheckedCreateWithoutPrimaryVendorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPrimaryVendorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPrimaryVendorInput, ProductUncheckedUpdateWithoutPrimaryVendorInput>
  }

  export type ProductUpdateManyWithWhereWithoutPrimaryVendorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutPrimaryVendorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    category?: StringFilter<"Product"> | string
    costPrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    wholesalePrice?: FloatNullableFilter<"Product"> | number | null
    stock?: IntFilter<"Product"> | number
    unit?: StringFilter<"Product"> | string
    minimumStock?: IntFilter<"Product"> | number
    expiryDate?: DateTimeNullableFilter<"Product"> | Date | string | null
    batchNumber?: StringNullableFilter<"Product"> | string | null
    manufacturer?: StringNullableFilter<"Product"> | string | null
    requiresPrescription?: BoolFilter<"Product"> | boolean
    activeIngredient?: StringNullableFilter<"Product"> | string | null
    dosage?: StringNullableFilter<"Product"> | string | null
    animalType?: StringNullableFilter<"Product"> | string | null
    nutritionInfo?: StringNullableFilter<"Product"> | string | null
    feedType?: StringNullableFilter<"Product"> | string | null
    primaryVendorId?: StringFilter<"Product"> | string
    alternateVendors?: JsonNullableFilter<"Product">
    active?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutVendorInput>
  }

  export type PaymentRecordUpsertWithWhereUniqueWithoutVendorInput = {
    where: PaymentRecordWhereUniqueInput
    update: XOR<PaymentRecordUpdateWithoutVendorInput, PaymentRecordUncheckedUpdateWithoutVendorInput>
    create: XOR<PaymentRecordCreateWithoutVendorInput, PaymentRecordUncheckedCreateWithoutVendorInput>
  }

  export type PaymentRecordUpdateWithWhereUniqueWithoutVendorInput = {
    where: PaymentRecordWhereUniqueInput
    data: XOR<PaymentRecordUpdateWithoutVendorInput, PaymentRecordUncheckedUpdateWithoutVendorInput>
  }

  export type PaymentRecordUpdateManyWithWhereWithoutVendorInput = {
    where: PaymentRecordScalarWhereInput
    data: XOR<PaymentRecordUpdateManyMutationInput, PaymentRecordUncheckedUpdateManyWithoutVendorInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutVendorInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutVendorInput, TransactionUncheckedUpdateWithoutVendorInput>
    create: XOR<TransactionCreateWithoutVendorInput, TransactionUncheckedCreateWithoutVendorInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutVendorInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutVendorInput, TransactionUncheckedUpdateWithoutVendorInput>
  }

  export type TransactionUpdateManyWithWhereWithoutVendorInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorCreateWithoutProductsInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutVendorInput
    Transaction?: TransactionCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutProductsInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutVendorInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutProductsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
  }

  export type TransactionItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
    transaction: TransactionCreateNestedOneWithoutItemsInput
  }

  export type TransactionItemUncheckedCreateWithoutProductInput = {
    id?: string
    transactionId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
  }

  export type TransactionItemCreateOrConnectWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    create: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput>
  }

  export type TransactionItemCreateManyProductInputEnvelope = {
    data: TransactionItemCreateManyProductInput | TransactionItemCreateManyProductInput[]
  }

  export type PurchaseOrderItemCreateWithoutProductInput = {
    id?: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseOrderId: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemCreateManyProductInputEnvelope = {
    data: PurchaseOrderItemCreateManyProductInput | PurchaseOrderItemCreateManyProductInput[]
  }

  export type VendorUpsertWithoutProductsInput = {
    update: XOR<VendorUpdateWithoutProductsInput, VendorUncheckedUpdateWithoutProductsInput>
    create: XOR<VendorCreateWithoutProductsInput, VendorUncheckedCreateWithoutProductsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutProductsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutProductsInput, VendorUncheckedUpdateWithoutProductsInput>
  }

  export type VendorUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type TransactionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    update: XOR<TransactionItemUpdateWithoutProductInput, TransactionItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput>
  }

  export type TransactionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    data: XOR<TransactionItemUpdateWithoutProductInput, TransactionItemUncheckedUpdateWithoutProductInput>
  }

  export type TransactionItemUpdateManyWithWhereWithoutProductInput = {
    where: TransactionItemScalarWhereInput
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransactionItemScalarWhereInput = {
    AND?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
    OR?: TransactionItemScalarWhereInput[]
    NOT?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
    id?: StringFilter<"TransactionItem"> | string
    transactionId?: StringFilter<"TransactionItem"> | string
    productId?: StringFilter<"TransactionItem"> | string
    quantity?: IntFilter<"TransactionItem"> | number
    unitPrice?: IntFilter<"TransactionItem"> | number
    total?: IntFilter<"TransactionItem"> | number
    productName?: StringFilter<"TransactionItem"> | string
    productSku?: StringFilter<"TransactionItem"> | string
    unit?: StringFilter<"TransactionItem"> | string
    batchNumber?: StringNullableFilter<"TransactionItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"TransactionItem"> | Date | string | null
    grade?: StringNullableFilter<"TransactionItem"> | string | null
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantityOrdered?: IntFilter<"PurchaseOrderItem"> | number
    quantityReceived?: IntFilter<"PurchaseOrderItem"> | number
    unitCost?: FloatFilter<"PurchaseOrderItem"> | number
    totalCost?: FloatFilter<"PurchaseOrderItem"> | number
    productName?: StringFilter<"PurchaseOrderItem"> | string
    productSku?: StringFilter<"PurchaseOrderItem"> | string
  }

  export type CustomerCreateWithoutTransactionsInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eggCollections?: EggCollectionCreateNestedManyWithoutFarmerInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutCustomerInput
    routes?: CollectionRouteCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutFarmerInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutCustomerInput
    routes?: CollectionRouteUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type VendorCreateWithoutTransactionInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutPrimaryVendorInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutTransactionInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPrimaryVendorInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutTransactionInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutTransactionInput, VendorUncheckedCreateWithoutTransactionInput>
  }

  export type StaffCreateWithoutTransactionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eggCollections?: EggCollectionCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutTransactionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteUncheckedCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutTransactionsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutTransactionsInput, StaffUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionItemCreateWithoutTransactionInput = {
    id?: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
    product: ProductCreateNestedOneWithoutTransactionItemsInput
  }

  export type TransactionItemUncheckedCreateWithoutTransactionInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
  }

  export type TransactionItemCreateOrConnectWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    create: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemCreateManyTransactionInputEnvelope = {
    data: TransactionItemCreateManyTransactionInput | TransactionItemCreateManyTransactionInput[]
  }

  export type PaymentRecordCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPaymentRecordsInput
    vendor?: VendorCreateNestedOneWithoutPaymentRecordsInput
    staff: StaffCreateNestedOneWithoutPaymentRecordsInput
  }

  export type PaymentRecordUncheckedCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    vendorId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateOrConnectWithoutTransactionInput = {
    where: PaymentRecordWhereUniqueInput
    create: XOR<PaymentRecordCreateWithoutTransactionInput, PaymentRecordUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentRecordCreateManyTransactionInputEnvelope = {
    data: PaymentRecordCreateManyTransactionInput | PaymentRecordCreateManyTransactionInput[]
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCollections?: EggCollectionUpdateManyWithoutFarmerNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutCustomerNestedInput
    routes?: CollectionRouteUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutFarmerNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutCustomerNestedInput
    routes?: CollectionRouteUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type VendorUpsertWithoutTransactionInput = {
    update: XOR<VendorUpdateWithoutTransactionInput, VendorUncheckedUpdateWithoutTransactionInput>
    create: XOR<VendorCreateWithoutTransactionInput, VendorUncheckedCreateWithoutTransactionInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutTransactionInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutTransactionInput, VendorUncheckedUpdateWithoutTransactionInput>
  }

  export type VendorUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutPrimaryVendorNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPrimaryVendorNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type StaffUpsertWithoutTransactionsInput = {
    update: XOR<StaffUpdateWithoutTransactionsInput, StaffUncheckedUpdateWithoutTransactionsInput>
    create: XOR<StaffCreateWithoutTransactionsInput, StaffUncheckedCreateWithoutTransactionsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutTransactionsInput, StaffUncheckedUpdateWithoutTransactionsInput>
  }

  export type StaffUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCollections?: EggCollectionUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUncheckedUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TransactionItemUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    update: XOR<TransactionItemUpdateWithoutTransactionInput, TransactionItemUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    data: XOR<TransactionItemUpdateWithoutTransactionInput, TransactionItemUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionItemUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionItemScalarWhereInput
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyWithoutTransactionInput>
  }

  export type PaymentRecordUpsertWithWhereUniqueWithoutTransactionInput = {
    where: PaymentRecordWhereUniqueInput
    update: XOR<PaymentRecordUpdateWithoutTransactionInput, PaymentRecordUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentRecordCreateWithoutTransactionInput, PaymentRecordUncheckedCreateWithoutTransactionInput>
  }

  export type PaymentRecordUpdateWithWhereUniqueWithoutTransactionInput = {
    where: PaymentRecordWhereUniqueInput
    data: XOR<PaymentRecordUpdateWithoutTransactionInput, PaymentRecordUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentRecordUpdateManyWithWhereWithoutTransactionInput = {
    where: PaymentRecordScalarWhereInput
    data: XOR<PaymentRecordUpdateManyMutationInput, PaymentRecordUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionCreateWithoutItemsInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    vendor?: VendorCreateNestedOneWithoutTransactionInput
    staff: StaffCreateNestedOneWithoutTransactionsInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutItemsInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutItemsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutTransactionItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryVendor: VendorCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransactionItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    primaryVendorId: string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransactionItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
  }

  export type TransactionUpsertWithoutItemsInput = {
    update: XOR<TransactionUpdateWithoutItemsInput, TransactionUncheckedUpdateWithoutItemsInput>
    create: XOR<TransactionCreateWithoutItemsInput, TransactionUncheckedCreateWithoutItemsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutItemsInput, TransactionUncheckedUpdateWithoutItemsInput>
  }

  export type TransactionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    vendor?: VendorUpdateOneWithoutTransactionNestedInput
    staff?: StaffUpdateOneRequiredWithoutTransactionsNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type ProductUpsertWithoutTransactionItemsInput = {
    update: XOR<ProductUpdateWithoutTransactionItemsInput, ProductUncheckedUpdateWithoutTransactionItemsInput>
    create: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransactionItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransactionItemsInput, ProductUncheckedUpdateWithoutTransactionItemsInput>
  }

  export type ProductUpdateWithoutTransactionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryVendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransactionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryVendorId?: StringFieldUpdateOperationsInput | string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutEggCollectionsInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutCustomerInput
    routes?: CollectionRouteCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutEggCollectionsInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutCustomerInput
    routes?: CollectionRouteUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutEggCollectionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutEggCollectionsInput, CustomerUncheckedCreateWithoutEggCollectionsInput>
  }

  export type CollectionRouteCreateWithoutEggCollectionsInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutCollectionRoutesInput
    customers?: CustomerCreateNestedManyWithoutRoutesInput
  }

  export type CollectionRouteUncheckedCreateWithoutEggCollectionsInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    staffId?: string | null
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutRoutesInput
  }

  export type CollectionRouteCreateOrConnectWithoutEggCollectionsInput = {
    where: CollectionRouteWhereUniqueInput
    create: XOR<CollectionRouteCreateWithoutEggCollectionsInput, CollectionRouteUncheckedCreateWithoutEggCollectionsInput>
  }

  export type StaffCreateWithoutEggCollectionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutEggCollectionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteUncheckedCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutEggCollectionsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutEggCollectionsInput, StaffUncheckedCreateWithoutEggCollectionsInput>
  }

  export type CustomerUpsertWithoutEggCollectionsInput = {
    update: XOR<CustomerUpdateWithoutEggCollectionsInput, CustomerUncheckedUpdateWithoutEggCollectionsInput>
    create: XOR<CustomerCreateWithoutEggCollectionsInput, CustomerUncheckedCreateWithoutEggCollectionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutEggCollectionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutEggCollectionsInput, CustomerUncheckedUpdateWithoutEggCollectionsInput>
  }

  export type CustomerUpdateWithoutEggCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutCustomerNestedInput
    routes?: CollectionRouteUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutEggCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutCustomerNestedInput
    routes?: CollectionRouteUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CollectionRouteUpsertWithoutEggCollectionsInput = {
    update: XOR<CollectionRouteUpdateWithoutEggCollectionsInput, CollectionRouteUncheckedUpdateWithoutEggCollectionsInput>
    create: XOR<CollectionRouteCreateWithoutEggCollectionsInput, CollectionRouteUncheckedCreateWithoutEggCollectionsInput>
    where?: CollectionRouteWhereInput
  }

  export type CollectionRouteUpdateToOneWithWhereWithoutEggCollectionsInput = {
    where?: CollectionRouteWhereInput
    data: XOR<CollectionRouteUpdateWithoutEggCollectionsInput, CollectionRouteUncheckedUpdateWithoutEggCollectionsInput>
  }

  export type CollectionRouteUpdateWithoutEggCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutCollectionRoutesNestedInput
    customers?: CustomerUpdateManyWithoutRoutesNestedInput
  }

  export type CollectionRouteUncheckedUpdateWithoutEggCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutRoutesNestedInput
  }

  export type StaffUpsertWithoutEggCollectionsInput = {
    update: XOR<StaffUpdateWithoutEggCollectionsInput, StaffUncheckedUpdateWithoutEggCollectionsInput>
    create: XOR<StaffCreateWithoutEggCollectionsInput, StaffUncheckedCreateWithoutEggCollectionsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutEggCollectionsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutEggCollectionsInput, StaffUncheckedUpdateWithoutEggCollectionsInput>
  }

  export type StaffUpdateWithoutEggCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutEggCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUncheckedUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffCreateWithoutCollectionRoutesInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutCollectionRoutesInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutCollectionRoutesInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutCollectionRoutesInput, StaffUncheckedCreateWithoutCollectionRoutesInput>
  }

  export type CustomerCreateWithoutRoutesInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    eggCollections?: EggCollectionCreateNestedManyWithoutFarmerInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRoutesInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutFarmerInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRoutesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRoutesInput, CustomerUncheckedCreateWithoutRoutesInput>
  }

  export type EggCollectionCreateWithoutRouteInput = {
    id?: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    farmer: CustomerCreateNestedOneWithoutEggCollectionsInput
    staff: StaffCreateNestedOneWithoutEggCollectionsInput
  }

  export type EggCollectionUncheckedCreateWithoutRouteInput = {
    id?: string
    farmerId: string
    staffId: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionCreateOrConnectWithoutRouteInput = {
    where: EggCollectionWhereUniqueInput
    create: XOR<EggCollectionCreateWithoutRouteInput, EggCollectionUncheckedCreateWithoutRouteInput>
  }

  export type EggCollectionCreateManyRouteInputEnvelope = {
    data: EggCollectionCreateManyRouteInput | EggCollectionCreateManyRouteInput[]
  }

  export type StaffUpsertWithoutCollectionRoutesInput = {
    update: XOR<StaffUpdateWithoutCollectionRoutesInput, StaffUncheckedUpdateWithoutCollectionRoutesInput>
    create: XOR<StaffCreateWithoutCollectionRoutesInput, StaffUncheckedCreateWithoutCollectionRoutesInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutCollectionRoutesInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutCollectionRoutesInput, StaffUncheckedUpdateWithoutCollectionRoutesInput>
  }

  export type StaffUpdateWithoutCollectionRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutCollectionRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type CustomerUpsertWithWhereUniqueWithoutRoutesInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutRoutesInput, CustomerUncheckedUpdateWithoutRoutesInput>
    create: XOR<CustomerCreateWithoutRoutesInput, CustomerUncheckedCreateWithoutRoutesInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutRoutesInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutRoutesInput, CustomerUncheckedUpdateWithoutRoutesInput>
  }

  export type CustomerUpdateManyWithWhereWithoutRoutesInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutRoutesInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    businessName?: StringNullableFilter<"Customer"> | string | null
    contactPerson?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: IntFilter<"Customer"> | number
    creditBalance?: IntFilter<"Customer"> | number
    paymentTerms?: IntFilter<"Customer"> | number
    creditStatus?: EnumCreditStatusFilter<"Customer"> | $Enums.CreditStatus
    farmSize?: FloatNullableFilter<"Customer"> | number | null
    animalTypes?: JsonNullableFilter<"Customer">
    henEggsDailyProduction?: IntFilter<"Customer"> | number
    duckEggsDailyProduction?: IntFilter<"Customer"> | number
    collectionSchedule?: EnumCollectionScheduleFilter<"Customer"> | $Enums.CollectionSchedule
    isRetail?: BoolFilter<"Customer"> | boolean
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalPurchases?: IntFilter<"Customer"> | number
    totalEggSales?: IntFilter<"Customer"> | number
    lastPurchase?: DateTimeNullableFilter<"Customer"> | Date | string | null
    lastEggCollection?: DateTimeNullableFilter<"Customer"> | Date | string | null
    active?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type EggCollectionUpsertWithWhereUniqueWithoutRouteInput = {
    where: EggCollectionWhereUniqueInput
    update: XOR<EggCollectionUpdateWithoutRouteInput, EggCollectionUncheckedUpdateWithoutRouteInput>
    create: XOR<EggCollectionCreateWithoutRouteInput, EggCollectionUncheckedCreateWithoutRouteInput>
  }

  export type EggCollectionUpdateWithWhereUniqueWithoutRouteInput = {
    where: EggCollectionWhereUniqueInput
    data: XOR<EggCollectionUpdateWithoutRouteInput, EggCollectionUncheckedUpdateWithoutRouteInput>
  }

  export type EggCollectionUpdateManyWithWhereWithoutRouteInput = {
    where: EggCollectionScalarWhereInput
    data: XOR<EggCollectionUpdateManyMutationInput, EggCollectionUncheckedUpdateManyWithoutRouteInput>
  }

  export type VendorCreateWithoutPurchaseOrdersInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutPrimaryVendorInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutVendorInput
    Transaction?: TransactionCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPrimaryVendorInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutVendorInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchaseOrdersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type StaffCreateWithoutPurchaseOrderInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutStaffInput
    paymentRecords?: PaymentRecordUncheckedCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutPurchaseOrderInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutPurchaseOrderInput, StaffUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    id?: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    productId: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
  }

  export type VendorUpsertWithoutPurchaseOrdersInput = {
    update: XOR<VendorUpdateWithoutPurchaseOrdersInput, VendorUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<VendorCreateWithoutPurchaseOrdersInput, VendorUncheckedCreateWithoutPurchaseOrdersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchaseOrdersInput, VendorUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type VendorUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutPrimaryVendorNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPrimaryVendorNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type StaffUpsertWithoutPurchaseOrderInput = {
    update: XOR<StaffUpdateWithoutPurchaseOrderInput, StaffUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<StaffCreateWithoutPurchaseOrderInput, StaffUncheckedCreateWithoutPurchaseOrderInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutPurchaseOrderInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutPurchaseOrderInput, StaffUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type StaffUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutStaffNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseOrdersInput
    staff: StaffCreateNestedOneWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    vendorId: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    orderedBy: string
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryVendor: VendorCreateNestedOneWithoutProductsInput
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    primaryVendorId: string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    staff?: StaffUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    orderedBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ProductUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryVendor?: VendorUpdateOneRequiredWithoutProductsNestedInput
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    primaryVendorId?: StringFieldUpdateOperationsInput | string
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CustomerCreateWithoutPaymentRecordsInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    eggCollections?: EggCollectionCreateNestedManyWithoutFarmerInput
    routes?: CollectionRouteCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutPaymentRecordsInput = {
    id?: string
    type: $Enums.CustomerType
    businessName?: string | null
    contactPerson: string
    email?: string | null
    phone?: string | null
    address?: string | null
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    creditStatus?: $Enums.CreditStatus
    farmSize?: number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: number
    duckEggsDailyProduction?: number
    collectionSchedule?: $Enums.CollectionSchedule
    isRetail?: boolean
    loyaltyPoints?: number
    totalPurchases?: number
    totalEggSales?: number
    lastPurchase?: Date | string | null
    lastEggCollection?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutFarmerInput
    routes?: CollectionRouteUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutPaymentRecordsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentRecordsInput, CustomerUncheckedCreateWithoutPaymentRecordsInput>
  }

  export type VendorCreateWithoutPaymentRecordsInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutPrimaryVendorInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    Transaction?: TransactionCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPaymentRecordsInput = {
    id?: string
    companyName: string
    contactPerson: string
    email?: string | null
    phone?: string | null
    street?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    country?: string
    creditLimit?: number
    creditBalance?: number
    paymentTerms?: number
    earlyPaymentDiscount?: number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: number
    onTimePaymentRate?: number
    lastOrder?: Date | string | null
    lastPayment?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutPrimaryVendorInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPaymentRecordsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPaymentRecordsInput, VendorUncheckedCreateWithoutPaymentRecordsInput>
  }

  export type TransactionCreateWithoutPaymentRecordsInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    vendor?: VendorCreateNestedOneWithoutTransactionInput
    staff: StaffCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentRecordsInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentRecordsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentRecordsInput, TransactionUncheckedCreateWithoutPaymentRecordsInput>
  }

  export type StaffCreateWithoutPaymentRecordsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutPaymentRecordsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position: $Enums.StaffPosition
    department: $Enums.StaffDepartment
    hireDate: Date | string
    salary: number
    active?: boolean
    username: string
    password?: string | null
    lastLogin?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: number | null
    averageQuality?: number | null
    onTimeRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutStaffInput
    eggCollections?: EggCollectionUncheckedCreateNestedManyWithoutStaffInput
    collectionRoutes?: CollectionRouteUncheckedCreateNestedManyWithoutStaffInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutPaymentRecordsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutPaymentRecordsInput, StaffUncheckedCreateWithoutPaymentRecordsInput>
  }

  export type CustomerUpsertWithoutPaymentRecordsInput = {
    update: XOR<CustomerUpdateWithoutPaymentRecordsInput, CustomerUncheckedUpdateWithoutPaymentRecordsInput>
    create: XOR<CustomerCreateWithoutPaymentRecordsInput, CustomerUncheckedCreateWithoutPaymentRecordsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentRecordsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentRecordsInput, CustomerUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type CustomerUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutFarmerNestedInput
    routes?: CollectionRouteUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutFarmerNestedInput
    routes?: CollectionRouteUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type VendorUpsertWithoutPaymentRecordsInput = {
    update: XOR<VendorUpdateWithoutPaymentRecordsInput, VendorUncheckedUpdateWithoutPaymentRecordsInput>
    create: XOR<VendorCreateWithoutPaymentRecordsInput, VendorUncheckedCreateWithoutPaymentRecordsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPaymentRecordsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPaymentRecordsInput, VendorUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type VendorUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutPrimaryVendorNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    creditLimit?: FloatFieldUpdateOperationsInput | number
    creditBalance?: FloatFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    earlyPaymentDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    productTypes?: JsonNullValueInput | InputJsonValue
    totalPurchases?: FloatFieldUpdateOperationsInput | number
    onTimePaymentRate?: FloatFieldUpdateOperationsInput | number
    lastOrder?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPayment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutPrimaryVendorNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type TransactionUpsertWithoutPaymentRecordsInput = {
    update: XOR<TransactionUpdateWithoutPaymentRecordsInput, TransactionUncheckedUpdateWithoutPaymentRecordsInput>
    create: XOR<TransactionCreateWithoutPaymentRecordsInput, TransactionUncheckedCreateWithoutPaymentRecordsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentRecordsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentRecordsInput, TransactionUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type TransactionUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    vendor?: VendorUpdateOneWithoutTransactionNestedInput
    staff?: StaffUpdateOneRequiredWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type StaffUpsertWithoutPaymentRecordsInput = {
    update: XOR<StaffUpdateWithoutPaymentRecordsInput, StaffUncheckedUpdateWithoutPaymentRecordsInput>
    create: XOR<StaffCreateWithoutPaymentRecordsInput, StaffUncheckedCreateWithoutPaymentRecordsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutPaymentRecordsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutPaymentRecordsInput, StaffUncheckedUpdateWithoutPaymentRecordsInput>
  }

  export type StaffUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutPaymentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: EnumStaffPositionFieldUpdateOperationsInput | $Enums.StaffPosition
    department?: EnumStaffDepartmentFieldUpdateOperationsInput | $Enums.StaffDepartment
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salary?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    username?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    totalCollections?: NullableIntFieldUpdateOperationsInput | number | null
    averageQuality?: NullableFloatFieldUpdateOperationsInput | number | null
    onTimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutStaffNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutStaffNestedInput
    collectionRoutes?: CollectionRouteUncheckedUpdateManyWithoutStaffNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TransactionCreateManyStaffInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionCreateManyStaffInput = {
    id?: string
    farmerId: string
    routeId?: string | null
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateManyStaffInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    vendorId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionRouteCreateManyStaffInput = {
    id?: string
    name: string
    description?: string | null
    estimatedTime: number
    estimatedDistance: number
    schedule?: $Enums.CollectionSchedule
    averageTime?: number | null
    onTimePercentage?: number | null
    totalCollections?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyStaffInput = {
    id?: string
    orderNumber: string
    vendorId: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    vendor?: VendorUpdateOneWithoutTransactionNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: CustomerUpdateOneRequiredWithoutEggCollectionsNestedInput
    route?: CollectionRouteUpdateOneWithoutEggCollectionsNestedInput
  }

  export type EggCollectionUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmerId?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmerId?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPaymentRecordsNestedInput
    vendor?: VendorUpdateOneWithoutPaymentRecordsNestedInput
    transaction?: TransactionUpdateOneWithoutPaymentRecordsNestedInput
  }

  export type PaymentRecordUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionRouteUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutRoutesNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutRouteNestedInput
  }

  export type CollectionRouteUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutRoutesNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type CollectionRouteUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyCustomerInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    vendorId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EggCollectionCreateManyFarmerInput = {
    id?: string
    routeId?: string | null
    staffId: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateManyCustomerInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    vendorId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutTransactionNestedInput
    staff?: StaffUpdateOneRequiredWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: CollectionRouteUpdateOneWithoutEggCollectionsNestedInput
    staff?: StaffUpdateOneRequiredWithoutEggCollectionsNestedInput
  }

  export type EggCollectionUncheckedUpdateWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUncheckedUpdateManyWithoutFarmerInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneWithoutPaymentRecordsNestedInput
    transaction?: TransactionUpdateOneWithoutPaymentRecordsNestedInput
    staff?: StaffUpdateOneRequiredWithoutPaymentRecordsNestedInput
  }

  export type PaymentRecordUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionRouteUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutCollectionRoutesNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutRouteNestedInput
  }

  export type CollectionRouteUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type CollectionRouteUncheckedUpdateManyWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedTime?: IntFieldUpdateOperationsInput | number
    estimatedDistance?: FloatFieldUpdateOperationsInput | number
    schedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    onTimePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCollections?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyPrimaryVendorInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ProductType
    category: string
    costPrice: number
    sellingPrice: number
    wholesalePrice?: number | null
    stock: number
    unit: string
    minimumStock?: number
    expiryDate?: Date | string | null
    batchNumber?: string | null
    manufacturer?: string | null
    requiresPrescription?: boolean
    activeIngredient?: string | null
    dosage?: string | null
    animalType?: string | null
    nutritionInfo?: string | null
    feedType?: string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyVendorInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    subtotal: number
    tax?: number
    shipping?: number
    total: number
    status?: $Enums.PurchaseOrderStatus
    orderedBy: string
    receivedBy?: string | null
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRecordCreateManyVendorInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    transactionId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyVendorInput = {
    id?: string
    receiptNumber: string
    type: $Enums.TransactionType
    customerId?: string | null
    subtotal: number
    tax: number
    discount?: number
    total: number
    paymentMethod: $Enums.PaymentMethod
    paidAmount?: number
    balanceAmount?: number
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    dueDate?: Date | string | null
    staffId: string
    notes?: string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutPrimaryVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPrimaryVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutPrimaryVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    category?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    minimumStock?: IntFieldUpdateOperationsInput | number
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    activeIngredient?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    animalType?: NullableStringFieldUpdateOperationsInput | string | null
    nutritionInfo?: NullableStringFieldUpdateOperationsInput | string | null
    feedType?: NullableStringFieldUpdateOperationsInput | string | null
    alternateVendors?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutPurchaseOrderNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    orderedBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    shipping?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    orderedBy?: StringFieldUpdateOperationsInput | string
    receivedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPaymentRecordsNestedInput
    transaction?: TransactionUpdateOneWithoutPaymentRecordsNestedInput
    staff?: StaffUpdateOneRequiredWithoutPaymentRecordsNestedInput
  }

  export type PaymentRecordUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    staff?: StaffUpdateOneRequiredWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paidAmount?: FloatFieldUpdateOperationsInput | number
    balanceAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staffId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionItemCreateManyProductInput = {
    id?: string
    transactionId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
  }

  export type PurchaseOrderItemCreateManyProductInput = {
    id?: string
    purchaseOrderId: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
  }

  export type TransactionItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionItemCreateManyTransactionInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    total: number
    productName: string
    productSku: string
    unit: string
    batchNumber?: string | null
    expiryDate?: Date | string | null
    grade?: string | null
  }

  export type PaymentRecordCreateManyTransactionInput = {
    id?: string
    type: $Enums.PaymentType
    amount: number
    customerId?: string | null
    vendorId?: string | null
    paymentMethod: $Enums.PaymentMethod
    paymentDate?: Date | string
    dueDate?: Date | string | null
    referenceNumber?: string | null
    checkNumber?: string | null
    processedBy: string
    notes?: string | null
    synced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionItemUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutTransactionItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionItemUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentRecordUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPaymentRecordsNestedInput
    vendor?: VendorUpdateOneWithoutPaymentRecordsNestedInput
    staff?: StaffUpdateOneRequiredWithoutPaymentRecordsNestedInput
  }

  export type PaymentRecordUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRecordUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    amount?: FloatFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkNumber?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionCreateManyRouteInput = {
    id?: string
    farmerId: string
    staffId: string
    collectionDate?: Date | string
    henEggsSmall?: number
    henEggsMedium?: number
    henEggsLarge?: number
    henEggsExtraLarge?: number
    henEggsDamaged?: number
    totalHenEggs?: number
    duckEggsSmall?: number
    duckEggsMedium?: number
    duckEggsLarge?: number
    duckEggsDamaged?: number
    totalDuckEggs?: number
    henEggPrice: number
    duckEggPrice: number
    totalValue: number
    qualityScore?: number | null
    qualityNotes?: string | null
    paid?: boolean
    paymentDate?: Date | string | null
    synced?: boolean
    cloudId?: string | null
    syncError?: string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    eggCollections?: EggCollectionUpdateManyWithoutFarmerNestedInput
    paymentRecords?: PaymentRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    eggCollections?: EggCollectionUncheckedUpdateManyWithoutFarmerNestedInput
    paymentRecords?: PaymentRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: IntFieldUpdateOperationsInput | number
    creditBalance?: IntFieldUpdateOperationsInput | number
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    farmSize?: NullableFloatFieldUpdateOperationsInput | number | null
    animalTypes?: NullableJsonNullValueInput | InputJsonValue
    henEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    duckEggsDailyProduction?: IntFieldUpdateOperationsInput | number
    collectionSchedule?: EnumCollectionScheduleFieldUpdateOperationsInput | $Enums.CollectionSchedule
    isRetail?: BoolFieldUpdateOperationsInput | boolean
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalPurchases?: IntFieldUpdateOperationsInput | number
    totalEggSales?: IntFieldUpdateOperationsInput | number
    lastPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEggCollection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    farmer?: CustomerUpdateOneRequiredWithoutEggCollectionsNestedInput
    staff?: StaffUpdateOneRequiredWithoutEggCollectionsNestedInput
  }

  export type EggCollectionUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmerId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EggCollectionUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    farmerId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    henEggsSmall?: IntFieldUpdateOperationsInput | number
    henEggsMedium?: IntFieldUpdateOperationsInput | number
    henEggsLarge?: IntFieldUpdateOperationsInput | number
    henEggsExtraLarge?: IntFieldUpdateOperationsInput | number
    henEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalHenEggs?: IntFieldUpdateOperationsInput | number
    duckEggsSmall?: IntFieldUpdateOperationsInput | number
    duckEggsMedium?: IntFieldUpdateOperationsInput | number
    duckEggsLarge?: IntFieldUpdateOperationsInput | number
    duckEggsDamaged?: IntFieldUpdateOperationsInput | number
    totalDuckEggs?: IntFieldUpdateOperationsInput | number
    henEggPrice?: FloatFieldUpdateOperationsInput | number
    duckEggPrice?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    qualityNotes?: NullableStringFieldUpdateOperationsInput | string | null
    paid?: BoolFieldUpdateOperationsInput | boolean
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    synced?: BoolFieldUpdateOperationsInput | boolean
    cloudId?: NullableStringFieldUpdateOperationsInput | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: string
    productId: string
    quantityOrdered: number
    quantityReceived?: number
    unitCost: number
    totalCost: number
    productName: string
    productSku: string
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityReceived?: IntFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    productName?: StringFieldUpdateOperationsInput | string
    productSku?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}